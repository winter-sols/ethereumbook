[[smart_contracts_chapter]]
== Smart contracts

As we discovered in <<intro>>, there are two different types of account in Ethereum: Externally Owned Accounts (EOAs) and contract accounts. EOAs are controlled by software, such as a wallet application, that is external to Ethereum. Contract accounts are controlled by software that runs within the Ethereum Virtual Machine (EVM). Both types of accounts are identified by an Ethereum address. In this section we will discuss the second type, contract accounts, and the software that controls them: smart contracts.

[[smart_contracts_definition]]
=== What is a smart contract?

The term _smart contract_ has been used to describe a wide variety of different things. In the 1990’s, cryptographer Nick Szabo coined the term and defined it as  “a set of promises, specified in digital form, including protocols within which the parties perform on the other promises.” Since then, the concept of smart contracts has evolved, especially after the introduction of decentralized blockchains with the invention of Bitcoin in 2009. In this book, we use the term “smart contract” to refer to immutable computer programs that run deterministically in the context of an Ethereum Virtual Machine, which operates as a decentralized world computer.

Let’s unpack that definition:

Computer programs: Smart contracts are simply computer programs. The word contract has no legal meaning in this context.
Immutable: Once deployed, the code of a smart contract cannot change. Unlike traditional software, the only way to modify a smart contract is to deploy a new instance.
Deterministically:  The outcome of a smart contract is the same for everyone who runs it, in the context of the transaction that called it and the state of the Ethereum blockchain at the moment of execution.
The EVM context: Smart contracts operate with a very limited execution context. They can access their own state, the context of the transaction that called them and some information about the most recent block.
Decentralized world computer: The EVM runs as a local instance on every Ethereum node, but because all instances of the EVM operate on the same initial state and produce the same final state, the system as a whole operates as a single world computer.

[[smart_contract_lifecycle]]
=== Lifecycle of a smart contract

Smart contracts are typically written in a high-level language, such as Solidity. But in order to run, they must be compiled to the low-level bytecode that runs in the EVM (see <<evm>>). Once compiled, they are deployed on the Ethereum blockchain with a transaction to a special contract-creation address. Each contract is identified by an Ethereum address, which is derived from the contract-creation transaction as a function of the originating account and nonce. The Ethereum address of a contract can be used in a transaction as the recipient, sending funds to the contract or calling one of the contract’s functions.

Importantly, contracts _only run if they are called by a transaction_. All smart contracts in Ethereum are executed by a transaction initiated from an Externally Owned Account. A contract can call another contract that can call another contract etc., but the first contract in such a chain of execution must always be called by a transaction from an EOA. Contracts never run “on their own”, or “run in the background”. Contracts effectively lie “dormant” on the blockchain until a transaction triggers execution, either directly or indirectly as part of a chain of contract calls.

Transactions are _atomic_, regardless of how many contracts they call or what those contracts do when called. Transactions execute in their entirety, with any changes in the global state (contracts, accounts, etc.) recorded only if a transaction terminates successfully. Successful termination means that the program executed without an error and reached the end of execution. If a transaction fails due to an error, all of its effects (changes in state) are “rolled back” as if the transaction never ran. A failed transaction is still stored on the blockchain and deducts the gas cost from the originating account, but has no other effects on contract or account state.

A contract’s code cannot be changed. However a contract can be “deleted”, removing the code and it’s internal state (variables) from the blockchain. To delete a contract, you execute an EVM opcode called +SELFDESTRUCT+ (previously called +SUICIDE+), which removes the contract from the blockchain. That operation costs “negative gas”, thereby incentivizing the release of stored state. Deleting a contract in this way does not remove the transaction history (past) of the contract, since the blockchain itself if immutable. But it does remove the contract state from all future blocks.

[[high_level_languages]]
=== Introduction to Ethereum high-level languages

The EVM is an emulated computer that runs a special form of _machine code_ called _EVM bytecode_, just like your computer's CPU, which runs machine code such as x86_64. We will examine the operation and language of the EVM in much more detail in <<evm>>. In this section we will look at how smart contracts are written to run on the EVM.

While it is possible to program smart contracts directly in bytecode, a low-level language like EVM bytecode is unwieldy and very difficult for programmers to read, understand, and collaborate. Instead, most Ethereum developers use a high-level symbolic language to write programs and a compiler to convert them into bytecode.

Ethereum has several high-level languages, with the compilers needed to produce EVM-executable bytecode. In general, programming languages can be classified in two broad programming paradigms: declarative and imperative, also known as “functional” and “procedural”, respectively. In declarative programming, we write functions that express the _logic_ of a program, but not its _flow_. Declarative programming is used to create programs where there are no _side effects_, meaning that there are no changes to state outside of a function. Declarative programming languages include, for example, Haskell, SQL and HTML. Imperative programming, by contrast, is where a programmer writes a set of procedures that combine the logic and flow of a program. Imperative programming languages include, for example, BASIC, C, C++, and Java. Some languages are “hybrid”, meaning that they encourage declarative programming but can also be used to express an imperative programming paradigm. Such hybrids include Lisp, Erlang, Prolog, JavaScript, and Python. In general, any imperative language can be used to write in a declarative paradigm, but it often results in innellegant code. By comparison, pure declarative languages cannot be used to write in an imperative paradigm. In purely declarative languages, _there are no “variables”_.

While imperative programming is easier to write and read, and is more commonly used by programmers, it can be very difficult to write programs that execute _exactly as expected_. The ability of any part of the program to change the state makes it difficult to reason about a program’s execution and introduces many opportunities for unintended side effects and bugs. Declarative programming by comparison is harder to write, but avoids side effects, making it easier to understand how a program will behave.

Smart contracts create a very high burden for programmers: bugs cost money. As a result, it is critically important to write smart contracts without unintended effects. To do that, you must be able to clearly reason about the expected behavior of the program. So, declarative languages play a much bigger role in smart contracts than they do in general purpose software. Nevertheless, as you will see below, the most prolific language for smart contracts (Solidity) is imperative.

High-level programming languages for smart contracts include (ordered by approximate age):

LLL:: A functional (declarative) programming language, with Lisp-like syntax. It was the first high-level language for Ethereum smart contracts, but it is rarely used.

Serpent:: A procedural (imperative) programming language with a syntax similar to Python. Can also be used to write functional (declarative) code, though it is not entirely free of side effects. Used sparsely. First created by Vitalik Buterin.

Solidity:: A procedural (imperative) programming language with a syntax similar to JavaScript, C++ or Java. The most popular and most frequently used language for Ethereum smart contracts. First created by Gavin Wood (co-author of this book).

Vyper:: A more recently developed language, similar to Serpent and with Python-like syntax. Intended to get closer to a pure-functional Python-like language than Serpent, but not to replace Serpent. First created by Vitalik Buterin.

Bamboo:: A newly developed language, influenced by Erlang with explicit state transitions and without iterative flows (loops). Intended to reduce side effects and increase auditability. Very new and rarely used.

As you can see, there are many languages to choose from. However, of all these Solidity is by far the most popular, to the point of being the de-facto high-level language of Ethereum and even other EVM-like blockchains. We will spend most of our time using Solidity, but will also explore some of the examples in other high-level languages, to gain an understanding of their different philosophies.

[[building_a_smart_contract_sec]]
=== Building a smart contract with Solidity

From Wikipedia:

[quote, "Wikipedia entry for Solidity"]
Solidity is a "contract-oriented" programming language for writing smart contracts. It is used for implementing smart contracts on various blockchain platforms. It was developed by Gavin Wood, Christian Reitwiessner, Alex Beregszaszi, Liana Husikyan, Yoichi Hirai and several former Ethereum core contributors to enable writing smart contracts on blockchain platforms such as Ethereum.

Solidity was proposed in 2014 by Gavin Wood, who is also on of the two authors of this book. It was further developed and currently maintained by a team of developers as the Solidity project on GitHub:

https://github.com/ethereum/solidity

The main "product" of the Solidity project is the _Solidity Compiler (solc)_ which converts programs written in the Solidity language to EVM bytecode (as well as producing other artefacts such as an Application Binary Interface). Each version of the Solidity compiler corresponds to and compiles a specific version of the Solidity language.

To use Solidity, you write your program using any text editor and then compile it using the Solidity compiler +solc+. The resulting binary contract (EVM bytecode) can be deployed to the Ethereum blockchain with a specially constructed contract-creation transaction.

To get started, we will download a binary executable of the Solidity compiler. Then we will write and compile a simple contract.

==== Selecting a version of Solidity

Solidity follows a versioning model called _semantic versioning_ (https://semver.org/), which specifies version numbers structured as three numbers separated by dots: +MAJOR.MINOR.PATCH+. The "major" number is incremented for major and _backwards incompatible_ changes, the "minor" number is incremented as backwards compatible features are added in between major releases, and the "patch" number is incremented for bug-fix and security related changes.

Currently, Solidity is at version 0.4.21, with the 0.5 release anticipated imminently.

As we saw in <<intro>>, your Solidity programs can contain a +pragma+ directive that specifies the minimum and maximum version of Solidity that is compatible with, and can be used to compile, your contract.

Since Solidity is rapidly evolving, it is best to always use the latest release of Solidity when your write Solidity code.

==== Download/install

There are a number of methods you can use to download and install Solidity, either as a binary release or to compile from source code. You can find detailed instruction in the Solidity documentation at:

https://solidity.readthedocs.io/en/latest/installing-solidity.html

In <<install_solidity_ubuntu>>, we will install the latest binary release of Solidity on an Ubuntu/Debian operating system, using the +apt+ package manager:

[[install_solidity_ubuntu]]
.Installing solc on Ubuntu/Debian with apt package manager
[source, bash]
----
$ sudo add-apt-repository ppa:ethereum/ethereum
$ sudo apt update
$ sudo apt install solc
----

Once you have +solc+ installed, check the version by running:

----
$ solc --version
solc, the solidity compiler commandline interface
Version: 0.4.21+commit.dfe3193c.Linux.g++
----

==== Development environment

To develop using Solidity, you can use any text editor and +solc+ on the command-line. However, you might find that some text editors designed for development, such as Atom, offer additional features such as syntax highlighting and macros that make Solidity development easier.

There are also web-based development environments, such as Remix, which we saw in <<intro>>.

Use the tools that make you productive. In the end, Solidity programs are just plain-text files. While fancy editors and development environments can make things a bit easier, you don't need anything more than a simple text editor, such as vim (Linux/Unix), TextEdit (MacOS) or even NotePad (Windows).

==== Writing a simple Solidity program

In <<intro>> we wrote our first Solidity program, called +Faucet+. We will revisit, improve and embellish +Faucet+ in this section.

Our first attempt looked like this:

.Faucet.sol : A Solidity contract implementing a faucet
[source,solidity,linenums]
----
include::code/Solidity/Faucet.sol[]
----

==== Compiling with the Solidity compiler (solc)

----
solcjs --bin foo.sol
----


[[eth_contract_abi_sec]]
=== Ethereum contract Application Binary Interface (ABI)

In computer software, an Application Binary Interface (ABI) is an interface between two program modules; often, one at the level of machine code, and the other at the level of a program run by a user. An ABI defines how data structures and computational routines are accessed in *machine code*; this is not to be confused with an API, which defines this access in high-level, often human-readable format as *source code*. The ABI is thus the primary way of encoding and decoding data into and out of machine code.

In Ethereum, the ABI is used to encode contract calls for the EVM and to read data out of transactions. As discussed in a previous section, an Ethereum smart contract is bytecode deployed on the blockchain under a *contract address*. The purpose of an ABI is to thus specify which functions in the contract to invoke and to get a guarantee that the function will return data in an expected format.

____
If an account or a web application wants to interact with a published contract and use one of its functions, the account would first need to hash the function's definition through an ABI to create its *EVM bytecode*. Then, to call the function, the account would pass this bytecode to a transaction's data field so that the bytecode could be interpreted with code at the contract's address. Thus, the two necessary pieces of information for an external function call would be the *ABI* and the *address of the contract wherein the function is written*. We demonstrate the use of an ABI in a detailed example below.
____

The JSON format for a contract's ABI is given by an array of function and event descriptions. A function description is a JSON object with fields for `type`, `name`, `inputs`, `outputs`, `constant`, and `payable`. An event description object has fields for `type`, `name`, `inputs`, and `anonymous`.

The ABI thus specifies information about functions in a smart contract, relaying information such as inputs and types. However, the ABI *only* contains information about functions and events, meaning it will not hold values for fields such as state variables or modifiers.

----
solcjs --abi foo.sol
----

[[structure_of_call_data_sec]]
==== Structure of call data

The data for a function call is a concatenation of several values of bytes. We discuss these in steps below.

*First Four Bytes*: The call data always begins with *four bytes* of the function signature. In specific, these are the first four bytes of the Keccak-256 hash of the *signature* of a function. In this context, the signature is simply the function name with a parenthesized list of parameter types split by a single comma.

Assume, as a running example, the brief contract `Test`:

[source,solidity]
contract Test {
  function foo(uint32 u, bool b) returns (bool b) { u > 2000 && b; }
}

.To encode function `foo(uint32 u, bool b)`:
* The signature of `foo(uint32 u, bool b)` would be `foo(uint32,bool)`
* Running `foo(uint32,bool)` through Keccak-256 outputs the hash `cc822237a37f9290b70dab4d640156d816bf8abdb959b5971d803a639dadef98`
* The first four bytes of the hash are `cc822237`, which brings us to a Method ID of `0xcc822237`
* Executing the command `web3.sha3("foo(uint32,bool)").substring(0, 10)` in the Go Ethereum (geth) JavaScript console produces the result `"0xcc822237"`

*5th Byte And On*: We continue our data by encoding the *arguments* of our function. Encoding a `uint32` means converting the number to hexadecimal form and padding it with 0's until it becomes 32 bytes long, while encoding a `bool` is equivalent to encoding a `uint` with values `1` for `true` and `0` for `false`. A full list of type encoding can be found at the link attached in the _Further Reading_ section.

.To continue with our example above, we call our function `foo` with parameters `2345` and `true`:
* The hexadecimal representation of `2345` is `0x929`, and so padded to 32 bytes the first argument `u` is encoded as `0x0000000000000000000000000000000000000000000000000000000000000929`
* The hexadecimal representation of `true` is `1`, and so padded to 32 bytes the second argument `b` becomes `0x0000000000000000000000000000000000000000000000000000000000000001`

*Result*: We concatenate the Method ID with our encoded arguments to reach the finished call data for our function call. In our case, the call data for function `foo(uint32 u, bool b)` with arguments `2345` and `true` is
`0xcc82223700000000000000000000000000000000000000000000000000000000000009290000000000000000000000000000000000000000000000000000000000000001`

____
We notice that our function returns a single `bool` value. For our choices of `u` and `b`, `foo` returns `true`, which would be the single byte array `0x0000000000000000000000000000000000000000000000000000000000000001`.
____

////
TO-DO: Discuss Events vs. Functions
////

[[further_reading_sec]]
==== Further reading

The Application Binary Interface (ABI) is strongly typed, known at compilation time and static. All contracts have the interface definitions of any contracts they intend to call available at compile-time.

A more rigorous and in-depth explanation of the Ethereum ABI can be found at
`https://solidity.readthedocs.io/en/develop/abi-spec.html`.
The link includes details about the formal specification of encoding and various helpful examples.

[[testing_frameworks]]
=== Testing smart contracts

////
TODO: add paragraph
////

[[deploying_smart_contracts_sec]]
=== Deploying smart contracts

After you've typed up your smart contract, you'll want to deploy it to the main Ethereum network.
The process is as follows:

1. Compile your Solidity source code to EVM bytecode
2. Sign the bytecode into a transaction
3. Send the code to an Ethereum node to be mined into the network
4. Then you can interact with the contract by sending it transactions


We'll now go through the deployment process using the Go Ethereum client (geth).
First, you'll want to install the Solidity compiler (solc).
----
npm install -g solc
----
You'll also want to have Geth (Go-ethereum) installed (with homebrew installed)
----
brew tap ethereum/ethereum
brew install ethereum
----
Now compile your Solidity file into an interface (abi) and bytecode (bin)
----
solcjs --abi foo.sol
solcjs --bin foo.sol
----
Now display the contents of these two files with:
----
more foo_sol_foo.abi
more foo_sol_foo.bin
----

After this you'll want to start up a geth node in a new terminal window with:
----
geth console
----
You should see something like:
----
Welcome to the Geth JavaScript console!

instance: Geth/v1.8.1-stable/darwin-amd64/go1.10
INFO [03-14|18:34:37] Etherbase automatically configured       address=0x6e6A1eFF05ba3a16c3A3E5a274B288b10490C428
coinbase: 0x6e6a1eff05ba3a16c3a3e5a274b288b10490c428
at block: 4535991 (Sat, 11 Nov 2017 21:17:37 EST)
 datadir: /Users/brianleffew/Library/Ethereum
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0
----

[[infura_sec]]
==== Infura

Infura is a free to use hosted Ethereum cluster that allows users to run an application without the need to run a full Ethereum node or a wallet. Infura is the same Ethereum provider that powers Metamask.

In order to use Infura for smart contract deployment, you must first get an Infura Access Token. To do so, visit the Infura Registration page and fill out the form. Once registered, the information will be sent to your email. It is important to save this token and keep it private.

To gain some exposure to deploying contracts with Infura, we will go through the steps of deploying a smart contract to the Ethereum Ropsten testnet using Truffle. For the purposes of this example we will assume that Truffle has already been installed and that you have already created a Truffle project with your smart contract. Refer to the Development Tools section for more information on installing and using Truffle.

Because Infura does not manage your private keys, Infura cannot sign transactions on your behalf. To deal with this, we will take advantage of Truffle’s HDWalletProvider which can handle both transaction signing and connection to the Ethereum network.

	npm install truffle-hdwallet-provider

After installation of the provider, we will want to edit our project’s truffle.js file. Add this line at the top:

	var HDWalletProvider = require(“truffle-hdwallet-provider”);

We must then provide a reference to the mnemonic that generates your accounts:

	var mnemonic = “<your mnemonic>“;



Now let’s make use of our newly acquired Infura Access Token to add a Ropsten network definition:

[source, JavaScript]
module.exports = {
	    networks: {
	        ropsten: {
		provider: function() {
		    return new HDWalletProvider (mnemonic, “https://ropsten.infura.io/<INFURA_Access_Token>”)
		},
		network_id: 3
	       }
	    }
};

In the above code, make sure to replace <INFURA_Access_Token> with your provided Access Token. Also, although the above HDWalletProvider is being returned with Ropsten as the desired network, it can be made to work with any of the Infura-supported networks, a list of which can be found on the Infura homepage.

The account in charge of deployment will be the first one generated by the mnemonic. To specify an account, add an integer input after the network declaration string. For example, to specify the second account:
[source, JavaScript]
return new HDWalletProvider (mnemonic, “https://ropsten.infura.io/<INFURA_Access_Token>”, 1)

Now we are ready to actually deploy our contract. First, make sure that your account has enough ether to deploy the contract. Now compile the project:

	truffle compile

Finally, deploy it to the network!

	truffle migrate --network ropsten
////
TODO use the example from the intro, incorporate infura, truffle deployment?, and expand on intro
////

[[testing_frameworks_sec]]
==== Testing Frameworks

There are several commonly-used test frameworks (no particular order)

Truffle Test:: Part of the Truffle framework, Truffle allows for unit tests to be written in Javascript (Mocha based) or Solidity. These tests are run against TestRPC/Ganache. More details on writing these tests are located at <<truffle>>

////
TODO: add anchor for <<truffle>>
////

Embark Framework Testing:: Embark integrates with Mocha to run unit tests written in Javascript. The tests are in turn run against contracts deployed on TestRPC/Ganache. The Embark Framework automatically deploys smart contracts and will automatically redeploy the contracts when they are changed. It also keeps track of deployed contracts and deploys contracts when truly needed. Embark includes a testing library to rapidly run and test your contracts in an EVM, with functions like ```assert.equal()```. ```embark test``` will run any test files under directory test/.

DApp:: DApp uses native Solidity code (a library called ds-test) and a Parity built Rust library called Ethrun to execute Ethereum bytecode and then assert correctness. The ds-test library provides assertion functions for validating correctness and events for logging data in the console.

Assertions Functions includes
....
assert(bool condition)
assertEq(address a, address b)
assertEq(bytes32 a, bytes32 b)
assertEq(int a, int b)
assertEq(uint a, uint b)
assertEq0(bytes a, bytes b)
expectEventsExact(address target)
....

Logging Events will log information to the console, making them useful for debugging.
....
logs(bytes)
log_bytes32(bytes32)
log_named_bytes32(bytes32 key, bytes32 val)
log_named_address(bytes32 key, address val)
log_named_int(bytes32 key, int val)
log_named_uint(bytes32 key, uint val)
log_named_decimal_int(bytes32 key, int val, uint decimals)
log_named_decimal_uint(bytes32 key, uint val, uint decimals)
....

Populus:: Populus uses python and its own chain emulator to run contracts written in solidity. Unit tests are written in Python with the pytest library. Populus supports writing contracts that are specifically for testing. These contract filenames should match the glob pattern ```Test*.sol``` and be located anywhere under the project tests directory ```./tests/```.

|=======
|Framework | Test Language(s)    | Testing Framework | Chain Emulator       | Website
|Truffle   | Javascript/Solidity | Mocha             | TestRPC/Ganache      | truffleframework.com
|Embark    | Javascript          | Mocha             | TestRPC/Ganache      | embark.readthedocs.io
|DApp      | Solidity            | ds-test (custom)  | Ethrun (Parity)      | dapp.readthedocs.io
|Populus   | Python              | Pytes             | Python chain emulator| populus.readthedocs.io
|=======

=======
If you this is your first time using geth, it might take a while to sync up to the network.
Then set up your variables with:
----
> var foo = eth(<CONTENTS_OF_ABI_FILE>)
> var byteCode = '0x<CONTENTS_OF_BIN_FILE>)
----
Fill in the parameters with the outputs from the more commands above.
Then finally deploy your contract with:
----
> var deploy = {from eth.coinbase, data:byteCode, gas:2000000}
> var fooInstance = foo(bar, baz)
----
=======

[[on_blockchain_testing_sec]]
==== On-Blockchain Testing

Although most testing shouldn't occur on deployed contracts, a contract's behavior can be checked via Ethereum clients.  The following commands can be used to assess a smart contract's state. These commands should be typed at the '+geth+' terminal, although any web3 calls will also support these commands.

....
eth.getTransactionReceipt(txhash);
....
Can be used to get the address of a contract at `+txhash+`.
....
eth.getCode(contractaddress)
....
Gets the code of a contract deployed at `+contractaddress+`. This can be used to verify proper deployment.
....
eth.getPastLogs(options)
....
Gets the full logs of the contract located at address, specified in options. This is helpful for viewing the history of a contract's calls.
....
eth.getStorageAt(address, position)
....
Gets the storage located at `+address+` with an offset of `+position+` shows the data stored in that contract.

[[best_practices_sec]]
=== Best Practices

Two of the most important concepts to consider during smart contract creation are *gas* and *security*.

[[gas_sec]]
==== Gas

*Gas* is described in more in detail in the <<gas>> section but is an incredibly important consideration in smart contract programming. Gas is a resource dictating the amount of computation power that a user will allot to a transaction. If the gas limit is exceeded during computation, the following series of events occurs:

* An exception is thrown
* The state of the contract prior to the function's execution is restored
* The entire amount of the gas is given to the miner as a transaction fee, it is *not* refunded

Because gas is paid by the user who creates that transaction, users are discouraged from calling functions that have a high gas cost. It is thus in the programmer's best interest to minimize the gas cost of a contract's functions. To this end, there are certain practices that are recommended when constructing smart contracts, so as to minimize the gas costs surrounding a function call.

*Avoid dynamically-sized Arrays*

* Any loop through a dynamically sized array wherein a function performs operations on each element or searches for a particular element is at the risk of gas overflow. The contract may run out of gas before finding the desired result, or before acting on every element.

*How do I estimate gas for a contract method?*

In case that you need to estimate the gas necessary to execute a certain method of a contract considering its call arguments, you can use for instance the following procedure;

[source, JavaScript]
var contract = web3.eth.contract(abi).at(address);
var gasEstimate = contract.myAweSomeMethod.estimateGas(arg1, arg2, {from: account});

*gasEstimate* will tell us the number of gas units needed for its execution.

To obtain the *gas price* from the network you can use;

[source, JavaScript]
var gasPrice = web3.eth.getGasPrice();

And from there, estimate the *gas cost*;

[source, JavaScript]
var gasCostInEther = web3.fromWei((gasEstimate * gasPrice), 'ether');

In *Truffle* this can be achieved as follows,

[source, JavaScript]
....
var METokenContract = artifacts.require("./METoken.sol");

METokenContract.web3.eth.getGasPrice(function(error, result) {
    var gasPrice = Number(result);
    console.log("Gas Price is " + gasPrice + " wei"); // "10000000000000"

    // Get the contract instance
    METokenContract.deployed().then(function(METokenContractInstance) {

        // Use the keyword 'estimateGas' after the function name to get the gas estimation for this particular function (aprove)
        return METokenContractInstance.aprove.estimateGas(_address, 100);

    }).then(function(result) {
        var gas = Number(result);

        console.log("gas estimation = " + gas + " units");
        console.log("gas cost estimation = " + (gas * gasPrice) + " wei");
        console.log("gas cost estimation = " + METokenContract.web3.fromWei((gas * gasPrice), 'ether') + " ether");
    });
});
....

Which could have an output similar to;

....
Gas Price is 20000000000 wei
gas estimation = 26794 units
gas cost estimation = 535880000000000 wei
gas cost estimation = 0.00053588 ether
....

[[security_sec]]
==== Security

With blockchain being in its early stages, *security* is one of the most important considerations when writing smart contracts. As with other programs, a smart contract will execute exactly what is written, which is not always equivalent to the intentions of the programmer. To this end, a programmer must understand common security exploits and proper ways to safeguard against these exploits. Here is a list of some of the security issues that have arisen in the past.

*Re-entrancy*

Re-entrancy is a phenomenon in programming in which a function or program is interrupted and then called again before its previous invocations have finished. In the context of smart contract programming, re-entrancy can occur when contract A calls a function in contract B, which in turn calls the same function in contract A, leading to a recursive execution. This can be particularly dangerous in a situation where the state of the contract is not updated until after the critical call is finished.

To understand this, imagine a withdrawal by a user calling a bank contract. User A calls the withdraw function in bank B, which executes the following actions:

//"User A" suggests an EOA account, yet it is a contract in this example.

. Checks if A has the available balance
. Calls A's default function, paying A in Ether
. Updates user A's balance within the contract

As a side note, the reason that the default function of A is called during a payout is that contract B allows A to execute code during this payout. For instance, if contract A kept count of the money it was being paid, it might need to change a variable called "balance," setting "balance" equal to its previous amount, plus what it was just paid.

However, malicious attackers can take advantage of this execution. Imagine that in A's default function, user A calls bank B's withdraw function once again. B will first check if A has the available balance, but since step 3 (which updates A's balance) has yet to be executed, it will appear to bank B that user A still has the available funds to withdraw, no matter how many times this function is re-invoked. Thus, "withdraw" can be called as long as there is gas available for execution.

This exploit is particularly famous because of its relevance in the DAO attack. A user took advantage of the fact that the balance in a contract was changed after a call to transfer funds was made and withdrew millions of dollars worth of ether.

To guard against re-entrancy, http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html[Solidity] recommends that a programmer adheres to the Checks-Effects-Interactions pattern, wherein the effects of a function call (such as decreasing the balance) occur before making the call. In our example, this would mean switching steps 3 and 2: updating a user's balance before paying them out. In ethereum, this is perfectly okay, because all effects of a transaction are atomic, meaning it is impossible for the balance to update without the user also being paid out. Either both occur, or an exception is thrown and neither occurs. This guards against re-entrancy attacks because all subsequent calls into the original contract will encounter the correct modified state.

*Delegate Call*:: //todo

////
TODO: add Delegate Call section ^
////

[[development_style_sec]]
==== Development style

////
TODO: add paragraph
////

[[design_patterns_sec]]
==== Design Patterns

Software developers of any programming paradigm generally experience reoccurring design challenges centered around the topics of behavior, structure, interaction, and creation. Often these problems can be generalized
and re-applied to future problems of a similar nature. When given a formal structure, these generalizations are called *Design Patterns*.
Smart contracts have their own set of reoccurring design problems that can be solved using some of the patterns described below.

There is an endless number of design problems in the development of smart contracts, making it impossible to discuss all of them
here. For that reason, this section will focus on three of the most pervasive problem classifications in smart contract design: *access control*, *state flow*, and *fund disbursement*.

Throughout this section, we will be working on a contract that will ultimately incorporate all three of these design patterns. This contract will run a voting system that
allows users to vote on "truth". The contract will suggest a claim such as "The Cubs won the World Series." or "It is raining in New York City" and then users will have
the opportunity to vote either true or false. The contract will consider the proposition as true if the majority of participants voted for true and likewise if the majority
of participants voted for false. To incentivize truthfulness, every vote must send 100 ether to the contract and the funds contributed by the losing minority will be split up amongst
the majority. Every participant in the majority will receive their portion of winnings from the minority as well as their initial investment.

This "truth voting" system is actually the foundation of Gnosis, a forecasting tool built on top of Ethereum. More information about Gnosis can be found here: https://gnosis.pm/

[[access_control_sec]]
===== Access control

Access control restricts which users may call contract functions. For the example, the owner of the truth voting contract may decide to limit those who can participate in the vote.
To accomplish this the contract must impose two access restrictions:

. Only an owner of the contract may add new users to the list of "allowed voters"
. Only allowed voters may cast a vote

Solidity function modifiers offer a concise way to implement these restrictions.

_Note: The following example uses an underscore semicolon within the modifier bodies. This is a Solidity feature used to tell the compiler when to run the modified function's body. A developer can act as if the modified function's body will be copied to the position of the underscore._
[source,solidity]
----
pragma solidity ^0.4.21;

contract TruthVote {

    address public owner = msg.sender;

    address[] true_votes;
    address[] false_votes;
    mapping (address => bool) voters;
    mapping (address => bool) hasVoted;

    uint VOTE_COST = 100;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlyVoter() {
        require(voters[msg.sender] != false);
        _;
    }

    modifier hasNotVoted() {
        require(hasVoted[msg.sender] == false);
        _;
    }

    function addVoter(address voter)
        public
        onlyOwner()
    {
        voters[voter] = true;
    }

    function vote(bool val)
        public
        payable
        onlyVoter()
        hasNotVoted()
    {
        if (msg.value >= VOTE_COST) {
            if (val) {
                true_votes.push(msg.sender);
            } else {
                false_votes.push(msg.sender);
            }
            hasVoted[msg.sender] = true;
        }
    }
}
----
*Description of Modifiers and Functions:*

- *onlyOwner*: this modifier can decorate a function such that the function will then only be callable by a sender with an address that matches that of *owner*.
- *onlyVoter*: this modifier can decorate a function such that the function will then only be callable by a registered voter.
- *addVoter(voter)*: this function is used to add a voter to the list of voters. This function uses the *onlyOwner* modifier so only the owner of this contract may call it.
- *vote(val)*: this function is used by a voter to vote either true or false to the presented proposition. It is decorated with the *onlyVoter* modifier so only registered voters may call it.

[[state_flow_sec]]
===== State flow

Many contracts will require some notion of operation state. The state of a contract will determine how the contract will behave and what operations it offers
at a given point in time. Let's return to our truth voting system for a more concrete example.

The operation of our voting system can be broken down into 3 distinct states.

. *Register*: The service has been created and the owner can now add voters.
. *Vote*:  All voters cast their votes.
. *Disperse*: Vote payments are divided and sent to the majority participants.

The following code continues to build on the access control code, but further restricts functionality to specific states.
In Solidity, it is commonplace to use enumerated values to represent states.

[source,solidity]
----
pragma solidity ^0.4.21;

contract TruthVote {
    enum States {
        REGISTER,
        VOTE,
        DISPERSE
    }

    address public owner = msg.sender;

    uint voteCost;

    address[] trueVotes;
    address[] falseVotes;


    mapping (address => bool) voters;
    mapping (address => bool) hasVoted;

    uint VOTE_COST = 100;

    States state;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlyVoter() {
        require(voters[msg.sender] != false);
        _;
    }

    modifier isCurrentState(States _stage) {
        require(state == _stage);
        _;
    }

    modifier hasNotVoted() {
        require(hasVoted[msg.sender] == false);
        _;
    }

    function startVote()
        public
        onlyOwner()
        isCurrentState(States.REGISTER)
    {
        goToNextState();
    }

    function goToNextState() internal {
        state = States(uint(state) + 1);
    }

    modifier pretransition() {
        goToNextState();
        _;
    }

    function addVoter(address voter)
        public
        onlyOwner()
        isCurrentState(States.REGISTER)
    {
        voters[voter] = true;
    }

    function vote(bool val)
        public
        payable
        isCurrentState(States.VOTE)
        onlyVoter()
        hasNotVoted()
    {
        if (msg.value >= VOTE_COST) {
            if (val) {
                trueVotes.push(msg.sender);
            } else {
                falseVotes.push(msg.sender);
            }
            hasVoted[msg.sender] = true;
        }
    }

    function disperse(bool val)
        public
        onlyOwner()
        isCurrentState(States.VOTE)
        pretransition()
    {
        address[] memory winningGroup;
        uint winningCompensation;
        if (trueVotes.length > falseVotes.length) {
            winningGroup = trueVotes;
            winningCompensation = VOTE_COST + (VOTE_COST*falseVotes.length) / trueVotes.length;
        } else if (trueVotes.length < falseVotes.length) {
            winningGroup = falseVotes;
            winningCompensation = VOTE_COST + (VOTE_COST*trueVotes.length) / falseVotes.length;
        } else {
            winningGroup = trueVotes;
            winningCompensation = VOTE_COST;
            for (uint i = 0; i < falseVotes.length; i++) {
                falseVotes[i].transfer(winningCompensation);
            }
        }

        for (uint j = 0; j < winningGroup.length; j++) {
            winningGroup[j].transfer(winningCompensation);
        }
    }
}
----

*Description of Modifiers and Functions:*

- *isCurrentState*: this modifier will require that the contract is in a specified state before continuing execution of the decorated function.
- *pretransition*: this modifier will transition to the next state before executing the rest of the decorated function
- *goToNextState*: function that transitions the contract to the next state
- *disperse*: function that calculates the majority and disperses winnings accordingly. Only the owner may call this function to officially close voting.
- *startVote*: function that the owner can use to start a vote.

It may be important to note that allowing the owner to close the voting process at will opens this contract up to abuse. In a more genuine implementation, the voting period should close after a publicly understood period of time. For the sake of this example, this is fine.

The additions made now ensure that voting is only allowed when the owner decides to start the voting period, users can only be registered by the owner before the vote happens, and funds are only dispersed after the vote closes.

[[withdraw_sec]]
===== Withdraw

Many contracts will offer some way for a user to retrieve money from it. In our working example, users of the majority are sent money directly when the contract
begins dispersing funds. Although this appears to work, it is an under-thought solution. The receiving address of the *addr.send()* call in *disperse* could be a contract that
has a fallback function which fails and consequently breaks *disperse*. This effectively stops all further majority participants from receiving their earning.
A better solution is to provide a withdraw function that a user can call to collect their earnings.

[source,solidity]
----
...

enum States {
    REGISTER,
    VOTE,
    DETERMINE,
    WITHDRAW
}

mapping (address => bool) votes;
uint trueCount;
uint falseCount;

bool winner;
uint winningCompensation;

modifier posttransition() {
    _;
    goToNextState();
}

function vote(bool val)
    public
    onlyVoter()
    isCurrentStage(State.VOTE)
{
    if (votes[msg.sender] == address(0) && msg.value >= VOTE_COST) {
        votes[msg.sender] = val;
        if (val) {
            trueCount++;
        } else {
            falseCount++;
        }
    }
}

function determine(bool val)
    public
    onlyOwner()
    isCurrentState(State.VOTE)
    pretransition()
    posttransition()
{
    if (trueCount > falseCount) {
        winner = true;
        winningCompensation = VOTE_COST + (VOTE_COST*false_votes.length) / true_votes.length;
    } else if (falseCount > trueCount) {
        winner = false;
        winningCompensation = VOTE_COST + (VOTE_COST*true_votes.length) / false_votes.length;
    } else {
        winningCompensation = VOTE_COST;
    }
}

function withdraw()
    public
    onlyVoter()
    isCurrentState(State.WITHDRAW)
{
    if (votes[msg.sender] != address(0)) {
        if (votes[msg.sender] == winner) {
            msg.sender.transfer(winningCompensation);
        }
    }
}

...
----

*Description of Modifiers and (Updated) Functions:*

- *posttransition*: transitions to the next state after the function call
- *determine*: this function is very similar to the previous *disperse* function except it now just calculates the winner and winning compensation and does not actually send any funds.
- *vote*: votes are now added to the votes mapping and true/false counters are incremented.
- *withdraw*: allows a voter to collect winnings (if any).



This way, if the send fails, it will only fail on the specific caller's case and not hinder all other user's ability to collect their winnings.

[[modularity_and_side_effects_sec]]
==== Modularity and side effects

////
TODO: add paragraph
////

[[contract_libraries_sec]]
==== Contract libraries

Github link: https://github.com/ethpm

Repository link: https://www.ethpm.com/registry

Website: https://www.ethpm.com/

Documentation: https://www.ethpm.com/docs/integration-guide

[[security_best_practices_sec]]
==== Security best practices

Github: https://github.com/ConsenSys/smart-contract-best-practices/

Docs: https://consensys.github.io/smart-contract-best-practices/

https://blog.zeppelin.solutions/onward-with-ethereum-smart-contract-security-97a827e47702

https://medium.com/zeppelin-blog/the-hitchhikers-guide-to-smart-contracts-in-ethereum-848f08001f05#.cox40d2ut

Perhaps the most fundamental software security principle consists in maximizing reuse of trusted code. In blockchain technologies, this is even condensed in an adage: "Do not roll your own crypto". In the case of smart contracts, this amounts to profiting as much as possible from freely available libraries that have been thoroughly vetted by the community.

In Ethereum, the most widely used solution is the https://openzeppelin.org/[OpenZeppelin] suite, an ample library of contracts ranging from implementations of `ERC20` and `ERC721` tokens, to many flavors of crowdsale models, to simple behaviors commonly found in contracts such as `Ownable`, `Pausable` or `LimitBalance`. The contracts in this repository have been extensively tested and in some cases even function as _de facto_ standard implementations. They are free to use, and are built and mantained by https://zeppelin.solutions[Zeppelin] together with an ever growing list of external contributors.

Also from Zeppelin is https://zeppelinos.org/[zeppelin_os], an open source platform of services and tools to develop and manage smart contract applications securely. zeppelin_os provides a layer on top of the EVM that makes it easy for developers to launch upgradeable DApps linked to an on-chain library of well tested contracts that are themselves upgradeable. Different versions of these libraries can coexist in the blockchain, and a vouching system allows users to propose or push improvements in different directions. A set of off-chain tools to debug, test, deploy and monitor decentralized applications is also provided by the platform.


[[style_guide_sec]]

==== Style guide

https://solidity.readthedocs.io/en/develop/style-guide.html
