== Smart Contracts

=== What is a Smart Contract?

A Smart Contract is a computer logic that, given certain conditions, can enforce the execution of one or more transactions in an irreversible and decentralized way without the need for third parties. The term was first used by Nick Szabo in 1994.

Bitcoin supports smart contracts in a limited way by _Turing incomplete_ Script language. On the other hand, the Ethereum blockchain uses a Turing complete virtual machine (the EVM) which makes the Smart Contracts essentially programs that run in a distributed way. In that sense, they are pieces of code that live on the blockchain and are executed when a corresponding transaction is sent and processed. They can read other contracts' data (if that second contract is designed for it), make decisions, send ether and execute other contracts' functions. Smart Contracts will exist and have the ability to run as long as the whole network exists, and will only stop if they run out of _gas_ or if they were programmed to self destruct.

In Ethereum, a smart contract is composed of different functions, and is completely reactive. This means that these functions are only executed in response to a transaction made to that specific contract, calling that specific function. It is possible for contracts to call other contracts while executing a function, but any chain of function calls must have originated with an EOA.

[[high_level_languages]]
=== Introduction to Ethereum High-Level Languages

The Ethereum Virtual Machine is an emulated computer that runs a special form of _machine code_ called _bytecode_, just like your computer's CPU which also runs machine code. While it is possible to program the EVM directly in bytecode, it's unwieldy and very difficult for programmers to read, understand, and collaborate in a low-level language like bytecode. Instead, we use a high-level symbolic language to write our program and a compiler to convert it into bytecode.

Ethereum has several high-level languages, with the compilers needed to produce EVM-executable bytecode, including (ordered by approximate age):

LLL:: A functional (declarative) programming language, with Lisp-like syntax. It was the first high-level language for Ethereum smart contracts, but it is rarely used.

Serpent:: A procedural (imperative) programming language with syntax similar to Python. Can also be used to write functional (declarative) code, though it is not entirely free of side-effects. Used sparsely. First created by Vitalik Buterin.

Solidity:: A procedural (imperative) programming language with syntax that is similar to JavaScript, C++ or Java. The most popular and most frequently used language for Ethereum smart contracts. First created by Gavin Wood (co-author of this book)

Vyper:: A more recently developed language, similar to Serpent and with Python-like syntax. Intended to get closer to a pure-functional Python-like language than Serpent, but not to replace Serpent. First created by Vitalik Buterin.

Bamboo:: A newly developed language, influenced by Erlang with explicit state transitions and without iterative flows (loops). Intended to reduce side-effects and increase auditability. Very new and rarely used.

As you can see, there many languages to choose from. However, of all these Solidity is by far the most popular, to the point of being the de-facto high-level language of Ethereum and even other EVM-like blockchains. We will spend most of our time using Solidity, but will also explore some of the examples in other high-level languages, to gain an understanding of their different philosophies.

=== Building a Smart Contract
Truffle:: (https://github.com/trufflesuite/truffle) a development enviroment, testing framework and asset pipeline for Ethereum.  It includes built in smart contract compilation, automated testing with Mocha and Chai, a deployment framework, and an interactive console for interacting with smart contracts.  See the frameworks section of this book for a detailed guide.


=== Testing Smart Contracts

=== Deploying Smart Contracts

=== Best Practices

Two of the most important concepts to consider during smart contract creation are *gas* and *security*.

*Gas* is described in more in detail in the <<Gas>> section, but is an incredibly important consideration in smart contract programming. Gas is a resource dictating the amount of computation power that a user will allot to a transaction. If the gas limit is exceeded during computation, the following series of events occurs:

* An exception is thrown
* The state of the contract prior to the function's execution is restored
* The entire amount of the gas is *not* refunded and is given to the miner as a transaction fee

Because gas is paid for by the user who creates that transaction, users are discouraged from calling functions that have a high gas cost. It is thus in the programmer's best interest to minimize the gas cost of a contract's functions. To this end, there are certain practices that are recommended when constructing smart contracts, so as to minimize the gas costs surrounding a function call

*Avoid dynamically-sized Arrays*:: Any loop through a dynamically sized array wherein a function performs operations on each element or searches for a particular element is at the risk of gas overflow. The contract may run out of gas before finding the desired result, or before acting on every element.

==== Development Style

==== Design Patterns

==== Modularity and Side Effects

==== Contract Libraries

Github link; https://github.com/ethpm

Repository link; https://www.ethpm.com/registry

Website; https://www.ethpm.com/

Documentation; https://www.ethpm.com/docs/integration-guide

==== Security Best Practices

Github: https://github.com/ConsenSys/smart-contract-best-practices/

Docs: https://consensys.github.io/smart-contract-best-practices/

https://blog.zeppelin.solutions/onward-with-ethereum-smart-contract-security-97a827e47702

https://openzeppelin.org/

https://github.com/OpenZeppelin/zeppelin-solidity

https://medium.com/zeppelin-blog/the-hitchhikers-guide-to-smart-contracts-in-ethereum-848f08001f05#.cox40d2ut
