[[smart_contracts_chapter]]
== Smart contracts

As we discussed in <<intro>>, there are two different types of account in Ethereum: Externally Owned Accounts (EOAs) and contract accounts. EOAs are controlled by users, often via software, such as a wallet application, that are external to the Ethereum platform. In contrast to that, contract accounts are controlled by their program code (also commonly referred to as smart contracts) that is executed by the Ethereum Virtual Machine (EVM). In short, EOA are simple accounts without any associated code or data storage, whereas contract accounts have both associated code and data storage. EOAs are controlled by transactions created and cryptographically signed with a private key in the "real world" external to and independent of the protocol, whereas contract accounts do not have private keys and so "control themselves" in the predetermined way prescribed by their smart contract code. Both types of accounts are identified by an Ethereum address. In this section, we will discuss contract accounts, and the program code that controls them: smart contracts.

[[smart_contracts_definition]]
=== What is a smart contract?

The term _smart contract_ has been used over the years to describe a wide variety of different things. In the 1990’s, cryptographer Nick Szabo coined the term and defined it as  “a set of promises, specified in digital form, including protocols within which the parties perform on the other promises”. Since then, the concept of smart contracts has evolved, especially after the introduction of decentralized blockchain platforms with the invention of Bitcoin in 2009. In the context of Ethereum, the term is actually a bit of a misnomer, given that Ethereum smart contracts are neither smart nor legal contracts, but the term has stuck. In this book, we use the term “smart contract” to refer to immutable computer programs that run deterministically in the context of an Ethereum Virtual Machine as part of the Ethereum network protocol, i.e. on the decentralized Ethereum world computer.

Let’s unpack that definition:

* Computer programs: Smart contracts are simply computer programs. The word contract has no legal meaning in this context.

* Immutable: Once deployed, the code of a smart contract cannot change. Unlike traditional software, the only way to modify a smart contract is to deploy a new instance.

* Deterministic:  The outcome of the execution of a smart contract is the same for everyone who runs it, given the context of the transaction that initiated its execution and the state of the Ethereum blockchain at the moment of execution.

* The EVM context: Smart contracts operate with a very limited execution context. They can access their own state, the context of the transaction that called them and some information about the most recent blocks.

* Decentralized world computer: The EVM runs as a local instance on every Ethereum node, but because all instances of the EVM operate on the same initial state and produce the same final state, the system as a whole operates as a single "world computer".

[[smart_contract_lifecycle]]
=== Lifecycle of a smart contract

Smart contracts are typically written in a high-level language, such as Solidity. But in order to run, they must be compiled to the low-level bytecode that runs in the EVM (see <<evm>>). Once compiled, they are deployed on the Ethereum platform using a special _contract creation_ transaction which is identified as such by being sent to the special contract creation address, namely +0x0+. Each contract is identified by an Ethereum address, which is derived from the contract creation transaction as a function of the originating account and nonce. The Ethereum address of a contract can be used in a transaction as the recipient, sending funds to the contract or calling one of the contract’s functions. Note that, unlike EOAs, there are no keys associated with an account created for a new smart contract. As the contract creator, you don't get any special privileges at the protocol level (although you can explicitly code them into the smart contract, of course). You certainly don't receive the private key for the contract account - it does't exist - we can say that smart contract accounts own themselves.

Importantly, contracts _only run if they are called by a transaction_. All smart contracts in Ethereum are executed, ultimately, because of a transaction initiated from an Externally Owned Account. A contract can call another contract that can call another contract, and so on, but the first contract in such a chain of execution will always have been called by a transaction from an EOA. Contracts never run “on their own”, or “run in the background”. Contracts effectively lie “dormant” until a transaction triggers execution, either directly or indirectly as part of a chain of contract calls. It is also worth noting that smart contracts are not executed "in parallel" in any sense - the Ethereum world computer can be considered to be a single-threaded machine.

Transactions are _atomic_, regardless of how many contracts they call or what those contracts do when called. Transactions execute in their entirety, with any changes in the global state (contracts, accounts, etc.) recorded only if all execution terminates successfully. Successful termination means that the program executed without an error and reached the end of execution. If execution fails due to an error, all of its effects (changes in state) are “rolled back” as if the transaction never ran. A failed transaction is still recorded as having been attempted, and the ether spent on gas for the execution is deducted from the originating account, but it otherwise has no other effects on contract or account state.

As mentioned above, it important to remember that a contract’s code cannot be changed. However a contract can be “deleted”, removing the code and it’s internal state (storage) from its address, leaving a blank account. Any transactions sent to that account address after the contract has been deleted do not result in any code execution, because there is no longer any code there to execute. To delete a contract, you execute an EVM opcode called +SELFDESTRUCT+ (previously called +SUICIDE+). That operation costs “negative gas”, a gas refund, thereby incentivizing the release of network client resources from the deletion of stored state. Deleting a contract in this way does not remove the transaction history (past) of the contract, since the blockchain itself is immutable. It is also important to note that the +SELFDESTRUCT+ capability will only be available if the contract author programmed the smart contract to have that functionality. If the contract's code does not have a +SELFDESTRUCT+ opcode, or it is inaccessible, the smart contract can not be deleted.

[[high_level_languages]]
=== Introduction to Ethereum high-level languages

The EVM is an virtual machine that runs a special form of _machine code_ called _EVM bytecode_, just like your computer's CPU, which runs machine code such as x86_64. We will examine the operation and language of the EVM in much more detail in <<evm>>. In this section we will look at how smart contracts are written to run on the EVM.

While it is possible to program smart contracts directly in bytecode, EVM bytecode is rather unwieldy and very difficult for programmers to read and understand. Instead, most Ethereum developers use a high-level language to write programs, and a compiler to convert them into bytecode.

While any high-level language could be adapted to write smart contracts, adapting an arbitrary language to be compilable to EVM bytecode is quite a cumbersome exercise and would in general lead to some amount of confusion. Smart contracts operate in a highly constrained and minimalistic execution environment (the EVM), where almost all of the usual user interfaces, operating system interfaces and hardware interfaces are not there. In addition, a special set of EVM specific system variables and functions need to be available. As such, it is easier to build a smart-contract language from scratch, than it is to constrain a general-purpose language and make it suitable for writing smart contracts. As a result, a number of special-purpose languages have emerged for programming smart contracts. Ethereum has several such languages, together with the compilers needed to produce EVM-executable bytecode.

In general, programming languages can be classified into two broad programming paradigms: declarative and imperative, also known as “functional” and “procedural”, respectively. In declarative programming, we write functions that express the _logic_ of a program, but not its _flow_. Declarative programming is used to create programs where there are no _side effects_, meaning that there are no changes to state outside of a function. Declarative programming languages include, for example, Haskell, SQL and HTML. Imperative programming, by contrast, is where a programmer writes a set of procedures that combine the logic and flow of a program. Imperative programming languages include, for example, BASIC, C, C++, and Java. Some languages are “hybrid”, meaning that they encourage declarative programming but can also be used to express an imperative programming paradigm. Such hybrids include Lisp, Erlang, Prolog, JavaScript, and Python. In general, any imperative language can be used to write in a declarative paradigm, but it often results in inelegant code. By comparison, pure declarative languages cannot be used to write in an imperative paradigm. In purely declarative languages, _there are no “variables”_.

While imperative programming is easier to write and read, and is more commonly used by programmers, it can be very difficult to write programs that execute _exactly as expected_. The ability of any part of the program to change the state makes it difficult to reason about a program’s execution and introduces many opportunities for unintended side effects and bugs. Declarative programming by comparison is harder to write, but avoids side effects, making it easier to understand how a program will behave.

Smart contracts create a very high burden for programmers: bugs cost money. As a result, it is critically important to write smart contracts without unintended effects. To do that, you must be able to clearly reason about the expected behavior of the program. So, declarative languages play a much bigger role in smart contracts than they do in general purpose software. Nevertheless, as you will see below, the most prolific language for smart contracts (Solidity) is imperative.

Currently supported high-level programming languages for smart contracts include (ordered by approximate age):

LLL:: A functional (declarative) programming language, with Lisp-like syntax. It was the first high-level language for Ethereum smart contracts (written by the co-author of this book, Gavin Wood), but it is rarely used today.

Serpent:: A procedural (imperative) programming language with a syntax similar to Python. Can also be used to write functional (declarative) code, though it is not entirely free of side effects. Used sparsely. First created by Vitalik Buterin.

Solidity:: A procedural (imperative) programming language with a syntax similar to JavaScript, C++ or Java. The most popular and most frequently used language for Ethereum smart contracts. Created by Gavin Wood (co-author of this book).

Vyper:: A more recently developed language, similar to Serpent and again with Python-like syntax. Intended to get closer to a pure-functional Python-like language than Serpent, but not to replace Serpent. Created by Vitalik Buterin.

Bamboo:: A newly developed language, influenced by Erlang with explicit state transitions and without iterative flows (loops). Intended to reduce side effects and increase auditability. Very new and yet to be widely adopted.

As you can see, there are many languages to choose from. However, of all these Solidity is by far the most popular, to the point of being the de-facto high-level language of Ethereum and even other EVM-like blockchains. We will spend most of our time using Solidity, but will also explore some of the examples in other high-level languages, to gain an understanding of their different philosophies.

[[building_a_smart_contract_sec]]
=== Building a smart contract with Solidity

Solidity was created by Gavin Wood (co-author of this book) as a language explicitly for writing smart contracts with features to directly support execution in the decentralized environment of the Ethereum world computer. The resulting attributes are quite general and so it has ended up being used for coding smart contracts on several other blockchain platforms. It was developed by Christian Reitiwessner and then also by Alex Beregszaszi, Liana Husikyan, Yoichi Hirai and several former Ethereum core contributors. Solidity is now developed and maintained as the Solidity project on GitHub:

https://github.com/ethereum/solidity

The main "product" of the Solidity project is the _Solidity Compiler (solc)_ which converts programs written in the Solidity language to EVM bytecode. The project also manages the important Application Binary Interface (ABI) standard for Ethereum smart contracts, which we will explore in detail in this chapter. Each version of the Solidity compiler corresponds to and compiles a specific version of the Solidity language.

To get started, we will download a binary executable of the Solidity compiler. Then we will develop and compile a simple contract, following on from the example we started with in <<intro>>.

==== Selecting a version of Solidity

Solidity follows a versioning model called _semantic versioning_ (https://semver.org/), which specifies version numbers structured as three numbers separated by dots: +MAJOR.MINOR.PATCH+. The "major" number is incremented for major and _backwards incompatible_ changes, the "minor" number is incremented as backwards compatible features are added in between major releases, and the "patch" number is incremented for bug-fix and security related changes.

Currently, Solidity is at version +0.4.21+, where +0.4+ is the major version, 21 is the minor version and anything specified after that is a patch release.  The 0.5 major version release of Solidity is anticipated imminently.

As we saw in <<intro>>, your Solidity programs can contain a +pragma+ directive that specifies the minimum and maximum version of Solidity that it is compatible with, and can be used to compile your contract.

Since Solidity is rapidly evolving it is best to always use the latest release.

==== Download and Install

There are a number of methods you can use to download and install Solidity, either as a binary release or to compile from source code. You can find detailed instruction in the Solidity documentation at:

https://solidity.readthedocs.io/en/latest/installing-solidity.html

In <<install_solidity_ubuntu>>, you can see how to install the latest binary release of Solidity on an Ubuntu/Debian operating system, using the +apt+ package manager:

[[install_solidity_ubuntu]]
.Installing solc on Ubuntu/Debian with apt package manager
[source, bash]
----
$ sudo add-apt-repository ppa:ethereum/ethereum
$ sudo apt update
$ sudo apt install solc
----

Once you have +solc+ installed, check the version by running:

----
$ solc --version
solc, the solidity compiler commandline interface
Version: 0.4.21+commit.dfe3193c.Linux.g++
----

There are a number of other ways to install Solidity, depending on your Operating System and requirements, including compiling from the source code directly. For more information see:

https://github.com/ethereum/solidity

==== Development environment

To develop in Solidity, you can use any text editor and +solc+ on the command-line. However, you might find that some text editors designed for development, such as Atom, offer additional features such as syntax highlighting and macros that make Solidity development easier.

There are also web-based development environments, such as Remix IDE (https://remix.ethereum.org/), and EthFiddle (https://ethfiddle.com/).

Use the tools that make you productive. In the end, Solidity programs are just plain-text files. While fancy editors and development environments can make things a bit easier, you don't need anything more than a simple text editor, such as vim (Linux/Unix), TextEdit (MacOS) or even NotePad (Windows). Simply save your program source code with a +.sol+ extension and it will be recognized by the Solidity compiler as a Solidity program.

==== Writing a simple Solidity program

In <<intro>> we wrote our first Solidity program, called +Faucet+.  When we first built the +Faucet+, we used the Remix IDE to compile and deploy the contract. In this section, we will revisit, improve, and embellish +Faucet+.

Our first attempt looked like this:

.Faucet.sol : A Solidity contract implementing a faucet
[source,solidity,linenums]
----
include::code/Solidity/Faucet.sol[]
----

We will build on this first example, starting in <<make_it_better>>.

==== Compiling with the Solidity compiler (solc)

Now, we will use the Solidity compiler on the command-line to compile our contract directly. The Solidity compiler +solc+ offers a variety of options, which you can see by passing the +--help+ argument.

We use the +--bin+ and +--optimize+ arguments of +solc+ to produce an optimized binary of our example contract:

[[compile_Faucet_with_solc]]
.Compiling Faucet.sol with solc
----
$ solc --optimize --bin Faucet.sol
======= Faucet.sol:Faucet =======
Binary:
6060604052341561000f57600080fd5b60cf8061001d6000396000f300606060405260043610603e5763ffffffff7c0100000000000000000000000000000000
0000000000000000000000006000350416632e1a7d4d81146040575b005b3415604a57600080fd5b603e60043567016345785d8a0000811115606357600080fd
5b73ffffffffffffffffffffffffffffffffffffffff331681156108fc0282604051600060405180830381858888f19350505050151560a057600080fd5b5056
00a165627a7a723058203556d79355f2da19e773a9551e95f1ca7457f2b5fbbf4eacf7748ab59d2532130029
----

The result that +solc+ produces is a hex serialized binary that can be submitted to the Ethereum blockchain.

[[eth_contract_abi_sec]]
=== Ethereum contract Application Binary Interface (ABI)

In computer software, an Application Binary Interface (ABI) is an interface between two program modules; often, one at the level of machine code, and the other at the level of a program run by a user. An ABI defines how data structures and functions are accessed in *machine code*; this is not to be confused with an API, which defines this access in high-level, often human-readable formats as *source code*. The ABI is thus the primary way of encoding and decoding data into and out of machine code.

In Ethereum, the ABI is used to encode contract calls for the EVM and to read data out of transactions. The purpose of an ABI is to define which functions in the contract can be invoked and describe how the function will accept arguments and return data.

The JSON format for a contract's ABI is given by an array of descriptions of functions (see <<solidity_functions>>) and events (see <<solidity_events>>). A function description is a JSON object with fields for `type`, `name`, `inputs`, `outputs`, `constant`, and `payable`. An event description object has fields for `type`, `name`, `inputs`, and `anonymous`.

We use the +solc+ command-line Solidity compiler to produce the ABI for our +Faucet.sol+ example contract:

----
solc --abi Faucet.sol
======= Faucet.sol:Faucet =======
Contract JSON ABI
[{"constant":false,"inputs":[{"name":"withdraw_amount","type":"uint256"}],"name":"withdraw","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"payable":true,"stateMutability":"payable","type":"fallback"}]
----

As you can see, the compiler produces a JSON object describing the two functions that are defined by +Faucet.sol+. This JSON object can be used by any application that wants to access the +Faucet+ contract once it is deployed. Using the ABI, an application such as a wallet or DApp browser can construct transactions that call the functions in +Faucet+, with the correct arguments and argument types. For example, a wallet would know that to call the function +withdraw+ it would have to provide a +uint256+ argument named +withdraw_amount+. The wallet could prompt the user to provide that value, then create a transaction that encodes it and executes the +withdraw+ function.

All that is needed for an application to interact with a contract is an ABI and the address where the contract has been deployed.

[[solidity_pragma]]
==== Selecting Solidity compiler and language version

As we see in <<compile_Faucet_with_solc>> our +Faucet+ contract compiles successfully with Solidity version 0.4.21. But what if we had used a different version of the Solidity compiler? The language is still in constant flux and things may change in unexpected ways. Our contract is fairly simple, but what if our program used a feature that was only added in Solidity version +0.4.19+ and we tried to compile it with +0.4.18+?

To resolve such issues, Solidity offers a _compiler directive_ known as a _version pragma_ that instructs the compiler that the program expects a specific compiler (and language) version. Let’s look at an example:

[[compiler_version]]
----
pragma solidity ^0.4.19;
----

The Solidity compiler reads the version pragma and will produce an error if the compiler version is incompatible with the version pragma. In this case, our version pragma says that this program can be compiled by a Solidity compiler with a minimum version +0.4.19+. The symbol ^ states, however, that we allow compilation of any _minor revisions_ above that +0.4.19+, e.g., +0.4.20+, but not +0.5.0+ (which is a major revision, not a minor revision). Pragma directives are not compiled into EVM bytecode. They are only used by the compiler to check compatibility.

Let’s add a pragma directive to our +Faucet+ contract. We will name the new file +Faucet2.sol+, to keep track of our changes as we proceed through these examples:

.Faucet2.sol : Adding the version pragma to Faucet
[source,solidity,linenums]
----
include::code/Solidity/Faucet2.sol[]
----

Adding a version pragma is a best practice, as it avoids problems with mismatched compiler and language versions. We will explore other best practices and continue to improve the +Faucet+ contract throughout this chapter.

=== Programming with Solidity

In this section, we will look at some of the capabilities of the Solidity language. As we mentioned in <<intro>> our first contract example was very simple and also flawed in many different ways. We'll gradually improve that example, while learning how to use Solidity. This won't be a comprehensive Solidity tutorial however, as Solidity is quite complex and rapidly evolving. We'll cover the basics and give you enough of a foundation to be able to explore the rest on your own. The complete documentation for Solidity can be found at:

https://solidity.readthedocs.io/en/latest/

==== Data types

First, let's look at some of the basic data types offered in Solidity:

boolean (+bool+):: Boolean value, +true+ or +false+, with logical operators +!+ (not), +&&+ (and), +||+ (or), +==+ (equal), +!=+ (not equal).

integer (+int+, +uint+):: Signed (+int+) and unsigned (+uint+) integers, declared in increments of 8 bits from +int8+ to +uint256+. Without a size suffix, they are set to 256 bits to match the word size of the EVM.

fixed point (+fixed+, +ufixed+):: Fixed point numbers, declared with (+u+)+fixedMxN+ where M is the size in bits (increments of 8 up to 256) and N is the number of decimals after the point (up to 18), e.g. +ufixed32x2+

address:: A 20-byte Ethereum address. The +address+ object has many helpful member functions, the main ones being +balance+ (returns the account balance) and +transfer+ (transfer ether to the account).

byte array (fixed):: Fixed size arrays of bytes, declared with +bytes1+ up to +bytes32+

byte array (dynamic):: Dynamic size arrays of bytes, declared with +bytes+ or +string+

enum:: User-defined type for enumerating discrete values: +enum NAME {LABEL1, LABEL 2, ...}

arrays:: An array of any type, either fixed or dynamic: +uint32[][5]+ is an array of five dynamic arrays of unsigned integers

struct:: User-defines data containers for grouping variables: +struct NAME {TYPE1 VARIABLE1; TYPE2 VARIABLE2; ...}

mapping:: Hash lookup tables for +key => value+ pairs: +mapping(KEY_TYPE => VALUE_TYPE) NAME;

In addition to the data types above, Solidity also offers a variety of value literals that can be used to calculate different units:

time units:: The units +seconds+, +minutes+, +hours+, and +days+ can be used as a suffix, converting to multiples of the base unit +seconds+.

ether units:: The units +wei+, +finney+, +szabo+, and +ether+ can be used as a suffix, converting to multiples of the base unit +wei+.

So far, in our +Faucet+ contract example, we used +uint+ (which is an alias for +uint256+), for the +withdraw_amount+ variable. We also indirectly used an +address+ variable, which we set with +msg.sender+. We will use some more of these data types in our examples, throughout this chapter.

Let's use one of the unit multipliers, to improve the readability of our example contract +Faucet+. In the +withdraw+ function we limit the maximum withdrawal, expressing the amount limit as +wei+, the base unit of ether:

----
require(withdraw_amount <= 100000000000000000);
----

That's not very easy to read, so we can improve our code by using the unit multiplier +ether+, to express the value in ether instead of wei:

----
require(withdraw_amount <= 0.1 ether);
----

==== Predefined global variables and functions

When a contract is executed in the EVM, it has access to a narrow set of global objects. These include the +block+, +msg+ and +tx+ objects. In addition, Solidity exposes a number of EVM opcodes as predefined Solidity functions. In this section we will examine the variables and functions you can access from within a smart contract in Solidity.

===== Transaction/message call context

The +msg+ object is the transaction call (EOA originated) or message call (contract originated) that launched this contract execution. It contains a number of useful attributes:

+msg.sender+:: We've already used this one. It represents the address that initiated this contract call, not necessarily the originating EOA that sent the transaction. If our contract was called directly by an EOA transaction, then this is the address that signed the transaction, but otherwise it will be a contract address.

+msg.value+:: The value of ether sent with this call (in wei).

+msg.gas+:: The amount of gas left in the gas supply of this execution environment. It has been deprecated and will be replaced with the +gasleft()+ function as of Solidity v0.4.21.

+msg.data+:: The data payload of this call into our contract.

+msg.sig+:: The first four bytes of the data payload, which is the function selector.

[NOTE]
====
Whenever a contract calls another contract, the values of all the attributes of +msg+ change, to reflect the new caller's information. The only exception to this is the +delegatecall+ function which runs the code of another contract/library within the original +msg+ context.
====

===== Transaction context

The +tx+ object provides a means of accessing transaction related information:

tx.gasprice:: The gas price in the calling transaction

tx.origin:: The address of the originating EOA for this transaction. WARNING: unsafe!

===== Block context

The +block+ object contains information about the current block:

block.blockhash(blockNumber):: The block hash of the specified block number, up to 256 blocks in the past. Deprecated and replaced with the +blockhash()+ function in Solidity v.0.4.22.

block.coinbase:: The address of the recipient of the current block's fees and block reward.

block.difficulty:: The difficulty (Proof-of-Work) of the current block.

block.gaslimit:: The maximum amount of gas that can be spent across all transactions included in the current block.

block.number:: The current block number (blockchain height).

block.timestamp:: The timestamp placed in the current block by the miner, since Unix epoch in seconds.

[[solidity_address_object]]
===== Address object

Any address, either passed as an input, or cast from a contract object, has a number of attributes and methods:

+address.balance+:: The balance of the address, in wei. For example, the current contract balance is +address(this).balance+.

+address.transfer(amount)+:: Transfer the amount (wei) to this address, throwing an exception on any error. We used this function in our +Faucet+ example as a method on the +msg.sender+ address, as +msg.sender.transfer()+.

+address.send(amount)+:: Similar to +transfer+ above, only instead of throwing an exception, it returns +false+ on error. WARNING: always check the return value of +send()+

+address.call(payload)+:: Low-level +CALL+ function - can construct an arbitrary message call with a data payload. Returns +false+ on error. WARNING: unsafe - recipient can (accidentally or maliciously) use up all your gas causing your contract to halt with an +OOG+ exception; always check the return value of +call()+

+address.callcode(payload)+:: Low-level +CALLCODE+ function - like +address(this).call(...)+ but with this contract's code replaced with that of +address+. Returns +false+ on error. WARNING: advanced use only!

+address.delegatecall()+:: Low-level +DELEGATECALL+ function - like +callcode(...)+ but with the full +msg+ context seen by the current contract. Returns +false+ on error. WARNING: advanced use only!

===== Built-in functions

Other functions worth noting are:

+addmod+, +mulmod+:: Modulo addition and multiplication. For example, +addmod(x,y,k)+ calculates +pass:[(x + y) % k]+.

+keccak256+, +sha256+, +sha3+, +ripemd160+:: Functions to calculate hashes with various standard hash algorithms.

+ecrecover+:: Recover the address used to sign a message, from the signature.

+selfdestrunct(recipient_address)+:: delete the current contract, sending any remaining ether in the account to +recipient_address+.

+this+:: the address of the currently executing contract account.

==== Contract definition

Solidity's main data type is the _contract_ object, which is defined at the top of our +Faucet+ example. Similar to any object in an object-oriented language, the contract is a container that includes data and methods.

Solidity offers two other objects that are similar to a contract:

interface:: An interface definition is structured exactly like a contract, except none of the functions are defined, they are only declared. This type of function declaration is often called a _stub_, as it tells you about the arguments and returns all types of functions without any implementation. It serves to specify a contract interface and if inherited, each of the functions must be specified in the child.

library:: A library contract is one that is meant to be deployed only once and used by other contracts, using the +delegatecall+ method (see <<solidity_address_object>>).

==== Functions

Within a contract, we define functions that can be called by an EOA transaction or another contract. In our +Faucet+ example, we have two functions: +withdraw+ and the (unnamed) _fallback_ function.

Functions are defined with the following syntax:

*function*{nbsp}FunctionName([_parameters_])
{*public*|*private*|*internal*|*external*}
[*pure*|*constant*|*view*|*payable*]
[_modifiers_]
[*returns*{nbsp}(_return types_)]

Let's look at each of these components:

FunctionName:: Defines the name of the function, which is used to call the function in a transaction (from an EOA), from another contract, or even from within the same contract. One function in each contract may be defined without a name, in which case it is the _fallback_ function, which is called when no other function is named. The fallback function cannot have any arguments or return anything.

parameters:: Following the name, we specify the arguments that must be passed to the function, with their names and types. In our +Faucet+ example we defined +uint withdraw_amount+ as the only argument to the +withdraw+ function.

The next set of keywords (+public+, +private+, +internal+, +external+) specify the function's _visibility_:

+public+:: Public is the default and such functions can be called by other contracts, EOA transactions or from within the contract. In our +Faucet+ example, both functions are defined as public.

+external+:: External functions are like public, except they cannot be called from within the contract, unless they are prefixed with the keyword +this+.

+internal+:: Internal functions are only accessible from within the contract - they cannot be called by another contract or EOA transaction. They can be called by derived contracts (those that inherit this one).

+private+:: Private functions are like internal functions but they cannot be called by derived contracts.

Keep in mind, the terms +internal+ and +private+ are somewhat misleading. Any function or data inside a contract is always _visible_ on the public blockchain, meaning that anyone can see the code or data. The keywords above only affect how and when a function can be _called_.

The next set of keywords (+pure+, +constant+, +view+, +payable+) affect the behavior of the function:

+constant+ or +view+:: A function marked as a _view_, promises not to modify any state. The term _constant_ is an alias for _view_ that will be deprecated. At this time, the compiler does not enforce the _view_ modifier, only producing a warning, but this is expected to become an enforced keyword in v0.5 of Solidity.

+pure+:: A pure function is one that neither reads nor writes any variables in storage. It can only operate on arguments and return data, without reference to any stored data. Pure functions are intended to encourage declarative-style programming without side-effects or state.

+payable+:: A payable function is one that can accept incoming payments. Functions without payable will reject incoming payments. There are two exceptions, due to design decisions in the EVM: coinbase payments and +SELFDESTRUCT+ inheritance will be paid, even if the fallback function is not attributed as payable, but this makes sense because code execution is not part of those payments anyway.

As you can see in our +Faucet+ example, we have one payable function (the fallback function), which is the only function that can receive incoming payments.

==== Contract constructor and selfdestruct

There is a special function that is only used once. When a contract is created, it also runs the _constructor function_ if one exists, to initialize the state of the contract. The constructor is run in the same transaction as the contract creation. The constructor function is optional. In fact, our +Faucet+ example has no constructor function.

Constructors can be specified in two ways. Up to Solidity v.0.4.21, the constructor is a function whose name matches the name of the contract:

[[old_constructor_style]]
.Constructor function prior to Solidity v0.4.22
----
contract MEContract {
	function MEContract() {
		// This is the constructor
	}
}
----

The difficulty with this format is that if the contract name is changed and the constructor function name is not changed, it is no longer a constructor. Likewise, if there is an accidental typo in the naming of the contract and/or constructor, the function is again no longer a constructor. This can cause some pretty nasty, unexpected and difficult to notice bugs. Imagine for example if the constructor is setting the owner of the contract for purposes of control. If the function is not actually the constructor because of a naming error, not only will the owner be left unset at the time of contract creation, but the function may also be deployed as a permanent and "callable" part of the contract, like a normal function, allowing any third party to hijack the contract and become the "owner" after contract creation.

To address the potential problems with constructor functions being based on having an identical name as the contract, Solidity v0.4.22 introduces a +constructor+ keyword that operates like a constructor function but does not have a name. Renaming the contract does not affect the constructor at all. Also, it is easier to identify which function is the constructor. It looks like this:

----
pragma ^0.4.22
contract MEContract {
	constructor () {
		// This is the constructor
	}
}
----

So, to summarize, a contract's lifecycle starts with a creation transaction from an EOA or contract account. If there is a constructor, it is executed as part of contract creation, to initialize the state of the contract as it is being created, and is then discarded.

The other end of the contract's lifecycle is _contract destruction_. contracts are destroyed by a special EVM opcode called +SELFDESTRUCT+. It used to be called +SUICIDE+, but that name was deprecated due to the negative associations of the word. In Solidity, this opcode is exposed as a high level built-in function called +selfdestruct+, which takes one argument: the address to receive any ether balance remaining in the contract account. It looks like this:

----
selfdestruct(address recipient);
----

Note that you must explicitly add this command to your contract if you want it to be deletable - this is the only way a contract can be deleted, and it is not present by default. In this way, users of a contract who might rely on a contract being there forever, can be certain that a contract can not be deleted if it doesn't have a +SELFDESTRUCT+ opcode.

==== Adding a constructor and selfdestruct to our Faucet example

The +Faucet+ example contract we introduced in <<intro_chapter>> does not have any constructor or selfdestruct functions. It is an eternal contract that cannot be deleted. Let's change that, by adding a constructor and +selfdestruct+ function. We probably want the +selfdestruct+ to be callable _only_ by the EOA that originally created the contract. By convention, this is usually stored in an address variable, called +owner+. Our constructor sets the owner variable and the +selfdestruct+ function will first check that the owner called it directly.

First our constructor:

----
// Version of Solidity compiler this program was written for
pragma solidity ^0.4.22;

// Our first contract is a faucet!
contract Faucet {

	address owner;

	// Initialize Faucet contract: set owner
	constructor() {
		owner = msg.sender;
	}

[...]
----

We've changed the pragma directive to specify v0.4.22 as the minimum version for this example, as we are using the new constructor keyword that only exists as of v.0.4.22 of Solidity. Our contract now has an +address+ type variable named +owner+. The name "owner" is not special in any way. We could call this address variable "potato" and still use it the same way. The name +owner+ simply makes the intention and purpose clear.

Then, our constructor, which runs as part of the contract creation transaction, assigns the address from +msg.sender+ to the +owner+ variable. We've used the +msg.sender+ in the +withdraw+ function to identify the initiator of the withdrawal request. In the constructor however, the +msg.sender+ is the EOA or contract address that initiated contract creation. We know this is the case _because_ this is a constructor function: it only runs once and only as a result of contract creation.

Ok, now we can add a function to destroy the contract. We need to make sure that only the owner can run this function, so we will use a +require+ statement to control access. Here's how it will look:

----
// Contract destructor
function destroy() public {
	require(msg.sender == owner);
	selfdestruct(owner);
}
----

If anyone other calls this +destroy+ function from an address other than +owner+, it will fail. But if the same address stored in +owner+ by the constructor calls it, the contract will selfdestruct and send any remaining balance to the +owner+ address. Note that we did not use the unsafe +tx.origin+ to determine whether the owner wished to destroy the contract - using +tx.orgin+ would allow malign contracts to destroy your contract even if you didn't want to.

==== Function modifiers

Solidity offers a special type of function which is called a _function modifier_. You apply modifiers to functions by adding the modifier name in the function declaration. Modifier functions are most often used to create conditions that apply to many functions within a contract. We have an access control statement already, in our +destroy+ function. Let's create a function modifier that expresses that condition:

[[function_modifier_onlyowner]]
.onlyOwner function modifier
----
modifier onlyOwner {
    require(msg.sender == owner);
    _;
}
----

In <<function_modifier_onlyowner>> we see the declaration of a function modifier, named +onlyOwner+. This function modifier sets a condition on any function that it modifies, requiring that the address stored as the +owner+ of the contract is the same as the address of the transaction's +msg.sender+. This is the basic design pattern for access control, allowing only the owner of a contract to execute any function that has the +onlyOwner+ modifier.

You may have noticed that our function modifier has a peculiar syntactic "placeholder" in it, an underscore followed by a semicolon (&#95;;). This placeholder is replaced by the code of the function that is being modified. Essentially, the modifier is "wrapped around" the modified function, placing its code in the location identified by the underscore character.

To apply a modifier, you add its name to the function declaration. More than one modifier can be applied to a function, as a comma-separated list, applied in the sequence they are declared.

Let's re-write our +destroy+ function to use the +onlyOwner+ modifier:

----
function destroy() public onlyOwner {
    selfdestruct(owner);
}
----

The function modifier's name (+onlyOwner+) is after the keyword +public+ and tells us that the +destroy+ function is modified by the +onlyOwner+ modifier. Essentially you can read this as "Only the owner can destroy this contract". In practice, the resulting code is equivalent to "wrapping" the code from +onlyOwner+ around +destroy+.

Function modifiers are an extremely useful tool because they allow us to write preconditions for functions and apply them consistently, making the code easier to read and, as a result, easier to audit for security. They are most often used for access control, as in the example <<function_modifier_onlyowner>>, but are quite versatile and can be used for a variety of other purposes.

Inside a modifier, you can access all the symbols (variables and arguments) visible to the modified function. In this case, we can access the +owner+ variable, which is declared within the contract. However, the inverse is not true: you cannot access any of the modifier's variables inside the modified function.

==== Contract inheritance

Solidity's contract object supports _inheritance_, which is a mechanism for extending a base contract with additional functionality. To use inheritance, specify a parent contract with the keyword +is+:

----
contract Child is Parent {
  ...
}
----

With this construct, the +Child+ contract inherits all the methods, functionality, and variables of +Parent+. Solidity also supports multiple inheritance, which can be specified by comma-separated contract names after the keyword +is+:

----
contract Child is Parent1, Parent2 {
  ...
}
----

Contract inheritance allows us to write our contracts in such a way as to achieve modularity, extensibility and reuse. We start with contracts that are simple and implement the most generic capabilities, then extend them by inheriting those capabilities in more specialized contracts.

In our +Faucet+ contract, we introduced the constructor and destructor, together with access control for an owner, assigned on construction. Those capabilities are quite generic: many contracts will have them. We can define them as generic contracts, then use inheritance to extend them to the +Faucet+ contract.

We start by defining a base contract +owned+, which has an +owner+ variable, setting it in the contract's constructor:

----
contract owned {
	address owner;

	// Contract constructor: set owner
	constructor() {
		owner = msg.sender;
	}

	// Access control modifier
	modifier onlyOwner {
	    require(msg.sender == owner);
	    _;
	}
}
----

Next, we define a base contract +mortal+, which inherits +owned+:

----
contract mortal is owned {
	// Contract destructor
	function destroy() public onlyOwner {
		selfdestruct(owner);
	}
}
----

As you can see, the +mortal+ contract can utilize the +onlyOwner+ function modifier, defined in +owned+. It indirectly also uses the +owner+ address variable and the constructor defined in +owned+. Inheritance makes each contract simpler and focused on the specific functionality of its class, allowing us to manage the details in a modular way.

Now we can further extend the +owned+ contract, inheriting its capabilities in +Faucet+:

----
contract Faucet is mortal {
    // Give out ether to anyone who asks
    function withdraw(uint withdraw_amount) public {
        // Limit withdrawal amount
        require(withdraw_amount <= 0.1 ether);
        // Send the amount to the address that requested it
        msg.sender.transfer(withdraw_amount);
    }
    // Accept any incoming amount
    function () public payable {}
}
----

By inheriting +mortal+, which in turn inherits +owned+, the +Faucet+ contract now has the constructor and destroy functions, and a defined owner. The functionality is the same as when those functions were within +Faucet+, but now we can reuse those functions in other contracts without writing them again. Code re-use and modularity make our code cleaner, easier to read, and easier to audit.

==== Error handling (assert, require, revert)

A contract call can terminate and return an error. Error handling in Solidity is handled by four functions: +assert+, +require+, +revert+, and +throw+ (now deprecated).

When a contract terminates with an error, all the state changes (changes to variables, balances, etc.) are reverted, all the way up the chain of contract calls, if more than one contract were called. This ensures that transactions are atomic, meaning they either complete successfully or have no effect on state and are reverted entirely.

The +assert+ and +require+ functions operate in the same way, evaluating a condition and stopping execution with an error if the condition is false. By convention, +assert+ is used when the outcome is expected to be true, meaning that we use +assert+ to test internal conditions. By comparison, +require+ is used when testing inputs (such as function arguments or transaction fields), setting our expectations for those conditions.

We've used +require+ in our function modifier +onlyOwner+, to test that the message sender is the owner of the contract:

----
require(msg.sender == owner);
----

The +require+ function acts as a _gate condition_, preventing execution of the rest of the function and producing an error if it is not satisfied.

As of Solidity v.0.4.22, +require+ can also include a helpful text message, that can be used to show the reason for the error. The error message is recorded in the transaction log. So we can improve our code, by adding an error message in our +require+ function:

----
require(msg.sender == owner, "Only the contract owner can call this function");
----

The +revert+ and +throw+ functions halt the execution of the contract and revert any state changes. The +throw+ function is obsolete and will be removed in future versions of Solidity - you should use +revert+ instead. The +revert+ function can also take an error message as the only argument, which is recorded in the transaction log.

Certain conditions in a contract will generate errors regardless of whether we explicitly check for them. For example, in our +Faucet+ contract, we don't check whether there is enough ether to satisfy a withdrawal request. That's because the +transfer+ function will fail with an error and revert the transaction if there is insufficient balance to make the transfer:

.The transfer function will fail if there is an insufficient balance
----
msg.sender.transfer(withdraw_amount);
----

However, it might be better to check explicitly and provide a clear error message on failure. We can do that by adding a require statement before the transfer:

----
require(this.balance >= withdraw_amount,
	"Insufficient balance in faucet for withdrawal request");
msg.sender.transfer(withdraw_amount);
----

Additional error checking code like this will increase gas consumption slightly, but it offers better error reporting than if omitted. Striking the right balance between gas consumption and verbose error checking is something you will need to decide based on the expected use of your contract. In the case of a +Faucet+ intended for a testnet, we'd probably err on the side of extra reporting even if it costs more gas. Perhaps for a mainnet contract we'd choose to be frugal with our gas usage instead.


==== Events

Events are Solidity constructs that facilitate the production of transaction logs. When a transaction completes (successfully or not), it produces a _transaction receipt_, as we will see in <<evm>>. The transaction receipt contains _log_ entries that provide information about the actions that occurred during the execution of the transaction. Events are the Solidity high-level objects that are used to construct these logs.

Events are especially useful for light clients and DApp services, which can "watch" for specific events and report them to the user-interface, or make a change in the state of the application to reflect an event in an underlying contract.

Event objects take arguments that are serialized and recorded in the transaction logs, in the blockchain. You can supply the keyword +indexed+, before an argument, to make the value part of an indexed table (hash table) that can be searched or filtered by an application.

We have not added any events in our +Faucet+ example, so far, so let's do that. We will add two events, one to log any withdrawals and one to log any deposits. We will call these events +Withdrawal+ and +Deposit+ respectively. First, we define the events, in the +Faucet+ contract:

----
contract Faucet is mortal {
	event Withdrawal(address indexed to, uint amount);
	event Deposit(address indexed from, uint amount);

	[...]
}
----

We've chosen to make the addresses +indexed+, to allow searching and filtering in any user interface built to access our +Faucet+.

Next, we use the +emit+ keyword to incorporate the event data in the transaction logs:

----
// Give out ether to anyone who asks
function withdraw(uint withdraw_amount) public {
    [...]
    msg.sender.transfer(withdraw_amount);
    emit Withdrawal(msg.sender, withdraw_amount);
}
// Accept any incoming amount
function () public payable {
    emit Deposit(msg.sender, msg.value);
}
----

The resulting +Faucet.sol+ contract looks like this:

[[Faucet8.sol]]
.Faucet8.sol: Revised Faucet contract, with events
[source,solidity,linenums]
----
include::code/Solidity/Faucet8.sol['code/Solidity/Faucet8.sol']
----


===== Catching Events

Ok, so we've setup our contract to emit events. How do we see the results of a transaction and "catch" the events? The +web3.js+ library provides a data structure as the result of a transaction that contains the transaction logs. Within those we can see the events generated by the transaction.

Let's use +truffle+ to run a test transaction on the revised +Faucet+ contract. Follow the instructions in <<truffle>> to setup a project directory and compile the +Faucet+ code. The source code can be found in the book's GitHub repository under:

----
code/truffle/FaucetEvents
----


[[testing_events_prep]]
----
$ truffle develop
truffle(develop)> compile
truffle(develop)> migrate
Using network 'develop'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0xb77ceae7c3f5afb7fbe3a6c5974d352aa844f53f955ee7d707ef6f3f8e6b4e61
  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0
Saving successful migration to network...
  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Deploying Faucet...
  ... 0xfa850d754314c3fb83f43ca1fa6ee20bc9652d891c00a2f63fd43ab5bfb0d781
  Faucet: 0x345ca3e014aaf5dca488057592ee47305d9b3e10
Saving successful migration to network...
  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0
Saving artifacts...

truffle(develop)> Faucet.deployed().then(i => {FaucetDeployed = i})
truffle(develop)> FaucetDeployed.send(web3.toWei(1, "ether")).then(res => { console.log(res.logs[0].event, res.logs[0].args) })
Deposit { from: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 18, c: [ 10000 ] } }
truffle(develop)> FaucetDeployed.withdraw(web3.toWei(0.1, "ether")).then(res => { console.log(res.logs[0].event, res.logs[0].args) })
Withdrawal { to: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 17, c: [ 1000 ] } }

----

After getting the deployed contract, using the +deployed()+ function, we execute two transactions. The first transaction is a deposit (using +send+), which emits a +Deposit+ event in the transaction logs:

----
Deposit { from: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 18, c: [ 10000 ] } }
----

Next, we use the +withdraw+ function to make a withdrawal. This emits a +Withdrawal+ event:

----
Withdrawal { to: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  amount: BigNumber { s: 1, e: 17, c: [ 1000 ] } }
----

To get these events, we looked at the +logs+ array returned as a result (+res+) of the transactions. The first log entry (+logs[0]+) contains an event name in +logs[0].event+ and the event arguments in +logs[0].args+. By showing these on the console, we can see the emitted event name and the event arguments.

Events are a very useful mechanism, not only for intra-contract communication, but also for debugging during development.

==== Calling other contracts (send, call, callcode, delegatecall)

Calling other contracts from within your contract is a very useful but potentially dangerous operation. We'll examine the various ways you can achieve this and evaluate the risks of each method. In short, the risks develop out of the fact that you may have no idea about a contract you are calling into or no idea about who is calling into your contract. When writing smart contracts, you must keep in mind that, while you are mostly expecting to be dealing with EOAs perhaps, there is nothing to stop arbitrarily complex and perhaps malign contracts from calling into and being called by your code.

===== Creating a new instance

The safest way to call another contract is if you create that other contract yourself. That way, you are certain of its interfaces and behavior. To do this, you can simply instantiate it, using the keyword +new+, as with any object-oriented language. In Solidity, the keyword +new+ will create the contract on the blockchain and return an object that you can use to reference it. Let's say you want to create and call a +Faucet+ contract, from within another contract called +Token+:


----
contract Token is mortal {
	Faucet _faucet;

	constructor() {
		_faucet = new Faucet();
	}
}
----

This mechanism for contract construction ensures that you know the exact type of contract and its interface. The contract +Faucet+ must be defined within the scope of +Token+, which you can do with an +import+ statement, if the definition is in another file:

----
import "Faucet.sol";

contract Token is mortal {
	Faucet _faucet;

	constructor() {
		_faucet = new Faucet();
	}
}
----

The +new+ keyword can also accept optional parameters to specify the +value+ of ether transfer on creation, and arguments passed to the new contract's constructor, if any:

----
import "Faucet.sol";

contract Token is mortal {
	Faucet _faucet;

	constructor() {
		_faucet = (new Faucet).value(0.5 ether)();
	}
}
----

We can also then call the +Faucet+ functions, which operate just like a method call. In this example, we call the +destroy+ function of +Faucet+, from within the +destroy+ function of +Token+:

----
import "Faucet.sol";

contract Token is mortal {
	Faucet _faucet;

	constructor() {
		_faucet = (new Faucet).value(0.5 ether)();
	}

	function destroy() ownerOnly {
		_faucet.destroy();
	}
}
----

Note that, while you are the owner of the Token contract, it is the Token contract itself that is the owner of the new Faucet contract, so only the Token contract can destroy this one.

===== Addressing an existing instance

Another way we can use to call a contract, is to cast the address of an existing instance of the contract. With this method, we apply a known interface to an existing instance. It is therefore critically important that we know, for sure, that the instance we are addressing is in fact of the same type as we assume. Let's look at an example:

----
import "Faucet.sol";

contract Token is mortal {

	Faucet _faucet;

	constructor(address _f) {
		_faucet = Faucet(_f);
		_faucet.withdraw(0.1 ether)
	}
}
----

Here, we take an address provided as an argument to the constructor, +_f+, and we cast it as a +Faucet+ object. This is much riskier than the previous mechanism, because we don't know for sure whether that address is a +Faucet+ object in the exact way we plan to treat it. When we call +withdraw+, we are assuming that it accepts the same arguments and executes the same code as our +Faucet+ declaration, but we can't be sure. For all we know, the +withdraw+ function at this address could execute something completely different from what we expect, even if it is named the same. Using addresses passed as input and casting them into specific objects is therefore much more dangerous than creating the contract ourselves.

===== Raw call, delegatecall

Solidity offers some even more "low-level" functions for calling other contracts. These correspond directly to EVM opcodes of the same name and allow us to construct a contract-to-contract call manually. As such, they represent the most flexible *and* the most dangerous mechanisms for calling other contracts.

Here's the same example, using a +call+ method:

----
contract Token is mortal {
	constructor(address _faucet) {
		_faucet.call("withdraw", 0.1 ether);
	}
}
----

As you can see, this type of +call+, is a _blind_ call into a function, very much like constructing a raw transaction, only from within a contract's context. It can expose our contract to a number of security risks, most importantly _re-entrancy_, which we will talk about in more detail in <<reentrancy>>. The +call+ function will return false if there is a problem, so we can evaluate the return value, for error handling:

----
contract Token is mortal {
	constructor(address _faucet) {
		if !(_faucet.call("withdraw", 0.1 ether)) {
			revert("Withdrawal from faucet failed");
		}
	}
}
----

Another variant of +call+ is +delegatecall+, which replaced the more dangerous +callcode+. The +callcode+ method will be deprecated soon, so it should not be used.

As mentioned in <<solidity_address_object>>, a +delegatecall+ is different from a +call+, in that the +msg+ context does not change. For example, whereas a +call+ changes the value of +msg.sender+ to be the calling contract, a +delegatecall+ keeps the same +msg.sender+ as it is in the calling contract. Essentially, +delegatecall+ runs the code of another contract inside the context of the execution of the current contract. It is most often used to invoke code from a +library+. It also allows you to draw on the pattern of using library functions stored elsewhere, but have that code work with the storage data of your contract.

The +delegate+ call should be used with great caution. It can have some unexpected effects, especially if the contract you call was not designed as a library.

Let's use an example contract to demonstrate the various call semantics used by +call+ and +delegatecall+ for calling libraries and contracts. We use an event to log the details of each call and see how the calling context changes depending on the call type:

[[call_examples_code]]
.CallExamples.sol: An example of different call semantics.
[source,solidity,linenums]
----
include::code/truffle/CallExamples/contracts/CallExamples.sol["code/truffle/CallExamples/contracts/CallExamples.sol"]
----

Our main contract is +caller+, which calls a library +calledLibrary+ and a contract +calledContract+. Both the called library and contract have identical functions +calledFunction+, which emit an event +calledEvent+. The event +calledEvent+ logs three pieces of data: +msg.sender+, +tx.origin+, and +this+. Each time +calledFunction+ is called it may have a different execution context (with different values for the potentially all the context variables), depending on whether it is called directly or through +delegatecall+.

In +caller+, we first call the contract and library directly, by invoking the +calledFunction+ in each. Then, we explicitly use the low-level functions +call+ and +delegatecall+ to call the +calledContract.calledFunction+. This way we can see how the various calling mechanisms behave.

Let's run this in a truffle development environment and capture the events, to see how it looks:

----
truffle(develop)> migrate
Using network 'develop'.
[...]
Saving artifacts...
truffle(develop)> web3.eth.accounts[0]
'0x627306090abab3a6e1400e9345bc60c78a8bef57'
truffle(develop)> caller.address
'0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f'
truffle(develop)> calledContract.address
'0x345ca3e014aaf5dca488057592ee47305d9b3e10'
truffle(develop)> calledLibrary.address
'0xf25186b5081ff5ce73482ad761db0eb0d25abfbf'
truffle(develop)> caller.deployed().then( i => { callerDeployed = i })

truffle(develop)> callerDeployed.make_calls(calledContract.address).then(res => { res.logs.forEach( log => { console.log(log.args) })})
{ sender: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x345ca3e014aaf5dca488057592ee47305d9b3e10' }
{ sender: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f' }
{ sender: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x345ca3e014aaf5dca488057592ee47305d9b3e10' }
{ sender: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
  from: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f' }

----

Let's see what happened here. We called the +make_calls+ function and passed the address of +calledContract+, then caught the four events emitted by each of the different calls. Look at the +make_calls+ function and let's walk through each step.

The first call is:

----
_calledContract.calledFunction();
----

Here, we're calling the +calledContract.calledFunction+ directly, using the high-level ABI for +calledFunction+. The event emitted is:

----
sender: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f',
origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
from: '0x345ca3e014aaf5dca488057592ee47305d9b3e10'
----

As you can see, +msg.sender+ is the address of the +caller+ contract. The +tx.origin+ is the address of our account +web3.eth.accounts[0]+ that sent the transaction to +caller+. The event was emitted by +calledContract+, as we can see from the last argument in the event.

The next call in +make_calls+, is to the library:

----
calledLibrary.calledFunction();
----

It looks identical to how we called the contract, but behaves *very* differently. Let's look at the second event emitted:

----
sender: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
origin: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
from: '0x8f0483125fcb9aaaefa9209d8e9d7b9c8b9fb90f'
----

This time, the +msg.sender+ is not the address of +caller+. Instead it is the address of our account, and is the same as the transaction origin. That's because when you call a library, the call is always +delegatecall+ and runs within the context of the caller. So, when +calledLibrary+ code was running, it inherited the execution context of +caller+, as if its code was running inside +caller+. The variable +this+ (shown as +from+ in the event emitted) is the address of +caller+, even though it is accessed from within +calledLibrary+.

The next two calls, using the low-level +call+ and +delegatecall+, verify our expectations, emitting events that mirror what we just saw above.

[[gas_sec]]
=== Gas considerations

Gas is described in more in detail in the <<gas>> section and is an incredibly important consideration in smart contract programming. Gas is a resource constraining the maximum amount of computation that Ethereum will allow a transaction to consume. If the gas limit is exceeded during computation, the following series of events occurs:

* An "out of gas" exception is thrown.
* The state of the contract prior to execution is restored (reverted).
* All ether used to pay for the gas is taken as a transaction fee; it is *not* refunded.

Because gas is paid by the user who initiates the transaction, users are discouraged from calling functions that have a high gas cost. It is thus in the programmer's best interest to minimize the gas cost of a contract's functions. To this end, there are certain practices that are recommended when constructing smart contracts, so as to minimize the gas costs surrounding a function call.

==== Avoid dynamically-sized arrays

Any loop through a dynamically sized array wherein a function performs operations on each element or searches for a particular element introduces the risk of using too much gas. Indeed, the contract may run out of gas before finding the desired result, or before acting on every element, thus wasting time and ether without giving any result at all.

==== Avoid calls to other contracts

Calling other contracts, especially when the gas cost of their functions is not known, introduces the risk of running out of gas. Avoid using libraries that are not well tested and broadly used. The less scrutiny a library has received from other programmers, the greater the risk of using it.

==== Estimating gas cost

In case that you need to estimate the gas necessary to execute a certain method of a contract considering its call arguments, you could, for instance, use the following procedure;

[source, JavaScript]
var contract = web3.eth.contract(abi).at(address);
var gasEstimate = contract.myAweSomeMethod.estimateGas(arg1, arg2, {from: account});

*gasEstimate* will tell us the number of gas units needed for its execution. It is an estimate because of the Turing completeness of the EVM - it is relatively trivial to create a function that will take excessively different amounts of gas to execute on each subsequent call. Even production code can change execution paths in subtle ways resulting in hugely different gas costs from one call to the call. However, most functions are sensible and +estimateGas+ will give a very good estimate most of the time.

To obtain the *gas price* from the network you can use;

[source, JavaScript]
var gasPrice = web3.eth.getGasPrice();

And from there, estimate the *gas cost*;

[source, JavaScript]
var gasCostInEther = web3.fromWei((gasEstimate * gasPrice), 'ether');

Let's apply our gas estimation functions to estimating the gas cost of our +Faucet+ example, using the code from the book's repository found here:

----
code/truffle/FaucetEvents
----

We start truffle in development mode, and execute a JavaScript file +gas_estimates.js+, which contains:

[source, JavaScript]
.gas_estimates.js: Using the estimateGas function
----
var FaucetContract = artifacts.require("./Faucet.sol");

FaucetContract.web3.eth.getGasPrice(function(error, result) {
    var gasPrice = Number(result);
    console.log("Gas Price is " + gasPrice + " wei"); // "10000000000000"

    // Get the contract instance
    FaucetContract.deployed().then(function(FaucetContractInstance) {

        // Use the keyword 'estimateGas' after the function name to get the gas estimation for this particular function (aprove)
		FaucetContractInstance.send(web3.toWei(1, "ether"));
        return FaucetContractInstance.withdraw.estimateGas(web3.toWei(0.1, "ether"));

    }).then(function(result) {
        var gas = Number(result);

        console.log("gas estimation = " + gas + " units");
        console.log("gas cost estimation = " + (gas * gasPrice) + " wei");
        console.log("gas cost estimation = " + FaucetContract.web3.fromWei((gas * gasPrice), 'ether') + " ether");
    });
});
----

Here's how that looks in the truffle development console:

----
$ truffle develop

truffle(develop)> exec gas_estimates.js
Using network 'develop'.

Gas Price is 20000000000 wei
gas estimation = 31397 units
gas cost estimation = 627940000000000 wei
gas cost estimation = 0.00062794 ether
----

It is recommended that you evaluate the gas cost of functions as part of your development workflow, to avoid any surprises when deploying contracts to the mainnet.


[[security_sec]]
=== Security considerations

Security is one of the most important considerations when writing smart contracts. In the field of smart-contract programming, mistakes are costly and easily exploited. As with other programs, a smart contract will execute exactly what is written, which is not always what the programmer intended. Furthermore, all smart contracts are public and any user can interact with them simply by creating a transaction. Any vulnerability can be exploited and losses are almost always impossible to recover. It is therefore critical to follow best practices and use well tested design patterns.

_Defensive programming_ is a style of programming that is particularly well suited to programming smart contracts and has the following characteristics:

Minimalism/Simplicity:: Complexity is the enemy of security. The simpler the code, and the less it does, the lower the chance of a bug or unforeseen effect. When first engaging in smart-contract programming, developers are tempted to try to write a lot of code. Instead, you should look through your smart-contract code and try to find ways to do less, with fewer lines of code, with less complexity and with fewer "features". If someone tells you that their project has produced "thousands of lines of code" for their smart contracts, you should question the security of that project. Simpler is more secure.

Code re-use:: As much as possible, try not to "reinvent the wheel". If a library or contract already exists that does most of what you need, re-use it. Within your own code, follow the DRY principle: Do not Repeat Yourself. If you see any snippet of code repeat more than once, ask yourself whether it could be written as a function or library and re-used. Code that has been extensively used and tested is likely more secure than any new code you write. Beware of any Not-Invented-Here attitude, where you are tempted to "improve" a feature or component by building it from scratch. The security risk is often greater than the improvement value.

Code quality:: Smart-contract code is unforgiving. Every bug can lead to monetary loss. You should not treat smart-contract programming the same way as general purpose programming. Writing DApps in Solidity is not like creating a web widget in javascript. Rather, you should apply rigorous engineering and software development methodologies, akin to aerospace engineering or a similarly unforgiving engineering discipline. Once you "launch" your code, there's little you can do to fix any problems.

Readability/Auditability:: Your code should be clear and easy to comprehend. The easier it is to read, the easier it is to audit. Smart contracts are public, as everyone can read the bytecode and anyone can reverse engineer it. Therefore, it is beneficial to develop your work in public, using collaborative and open source methodologies, to draw upon the collective wisdom of the developer community and benefit from the highest common denominator of open source development. You should write code that is well documented and easy to read, following the style and naming conventions that are part of the Ethereum community.

Test coverage:: Test everything that you can test. Smart contracts run in a public execution environment, where anyone can execute them with whatever input they want. You should never assume that input, such as function arguments, is well formed, properly bounded and has a benign purpose. Test all arguments to make sure they are within expected ranges and properly formatted before allowing execution of your code to continue.

==== Common security risks

As a smart contract programmer, you should be familiar with the most common security risks, so as to be able to detect and avoid the programming patterns that leave them exposed to these risks.

==== Re-Entrancy

One of the features of Ethereum smart contracts is the ability to call
and utilise code of other external contracts. Contracts also typically
handle ether, and as such often send ether to various external user
addresses. The operation of calling external contracts, or sending ether
to an address, requires the contract to submit an external call. These
external calls can be hijacked by attackers whereby they force the
contract to execute further code (i.e. through a fallback function),
including calls back into itself. Thus the code execution
"__re-enters__" the contract. Attacks of this kind were used in the
infamous DAO hack.

For further reading on re-entrancy attacks, see
https://medium.com/@gus_tavo_guim/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4[Reentrancy
Attack On Smart Contracts] or
https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert[Consensus - Ethereum Smart Contract Best Practices].  

===== The Vulnerability

This attack can occur when a contract sends ether to an unknown address.
An attacker can carefully construct a contract at an external address
which contains malicious code in the
https://solidity.readthedocs.io/en/latest/contracts.html?highlight=fallback#fallback-function[fallback
function]. Thus, when a contract sends ether to this address, it will
invoke the malicious code. Typically the malicious code executes a
function on the vulnerable contract, performing operations not expected
by the developer. The name "re-entrancy" comes from the fact that the
external malicious contract calls back a function on the vulnerable
contract and "__re-enters__" code execution at an arbitrary location
on the vulnerable contract.

To clarify this, consider the simple vulnerable contract, which acts as
an Ethereum vault that allows depositors to only withdraw 1 ether per
week.

.EtherStore.sol:
[source,solidity,linenums]
----
contract EtherStore {

    uint256 public withdrawalLimit = 1 ether;
    mapping(address => uint256) public lastWithdrawTime;
    mapping(address => uint256) public balances;
    
    function depositFunds() public payable {
        balances[msg.sender] += msg.value;
    }
    
    function withdrawFunds (uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
        // limit the withdrawal
        require(_weiToWithdraw <= withdrawalLimit);
        // limit the time allowed to withdraw
        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
        require(msg.sender.call.value(_weiToWithdraw)());
        balances[msg.sender] -= _weiToWithdraw;
        lastWithdrawTime[msg.sender] = now;
    }
 }
----

This contract has two public functions. `depositFunds()` and
`withdrawFunds()`. The `depositFunds()` function simply increments the
senders balances. The `withdrawFunds()` function allows the sender to
specify the amount of wei to withdraw. This function is intended to succeed
only if the requested amount to withdraw is less than 1 ether and a withdrawal
has not occurred in the last week. 

The vulnerability comes on line [17] where the contract sends the user their
requested amount of ether. Consider a malicious attacker creating the
following contract,

.Attack.sol:
[source,solidity,linenums]
----
import "EtherStore.sol";

contract Attack {
  EtherStore public etherStore;

  // intialise the etherStore variable with the contract address
  constructor(address _etherStoreAddress) {
      etherStore = EtherStore(_etherStoreAddress);
  }
  
  function attackEtherStore() public payable {
      // attack to the nearest ether
      require(msg.value >= 1 ether);
      // send eth to the depositFunds() function
      etherStore.depositFunds.value(1 ether)();
      // start the magic
      etherStore.withdrawFunds(1 ether);
  }
  
  function collectEther() public {
      msg.sender.transfer(this.balance);
  }
    
  // fallback function - where the magic happens
  function () payable {
      if (etherStore.balance > 1 ether) {
          etherStore.withdrawFunds(1 ether);
      }
  }
}
----

Let us examine how this malicious contract can exploit the `EtherStore`
contract. The attacker would create the above contract (let’s say at the
address `0x0...123`) with the `EtherStore`’s contract address as the sole
constructor parameter. This will initialize and point the public
variable `etherStore` to the contract to be attacked.

The attacker would then call the `attackEtherStore()` function, with some
amount of ether (greater than or equal to 1), let us assume `1 ether` for
the time being. In this example, we will also assume a number of other users have
deposited ether into this contract, such that it’s current balance is
`10 ether`. The following would then occur:

1. *Attack.sol - Line [15]* - The `depositFunds()` function of the EtherStore
contract will be called with a `msg.value` of `1 ether` (and a lot of gas). The
sender (`msg.sender`) will be our malicious contract (`0x0...123`). Thus,
       `balances[0x0..123] = 1 ether`.

2. *Attack.sol - Line [17]* - The malicious contract will then call the
`withdrawFunds()` function of the `EtherStore` contract with a parameter of `1
ether`. This will pass all the requirements (Lines [12]-[16] of the
    `EtherStore` contract) as no previous withdrawals have been made.

3. *EtherStore.sol - Line [17]* - The contract will then send `1 ether` back to
the malicious contract. 

4. *Attack.sol - Line [25]* - The ether sent to the malicious contract will
then execute the fallback function. 

5. *Attack.sol - Line [26]* - The total balance of the EtherStore contract was
`10 ether` and is now `9 ether` so this if statement passes. 

6. *Attack.sol - Line [27]* - The fallback function then calls the `EtherStore`
`withdrawFunds()` function again and '__re-enters__' the `EtherStore`
contract. 

7. *EtherStore.sol - Line [11]* - In this second call to `withdrawFunds()`, the
attacking contract's balance is still `1 ether` as line [18] has not yet been executed. Thus, we
still have `balances[0x0..123] = 1 ether`. This is also the case for the
`lastWithdrawTime` variable. Again, we pass all the requirements. 

8. *EtherStore.sol - Line [17]* - The attacking contract withdraws another `1 ether`.

9. *Steps 4-8 will repeat* - until `EtherStore.balance >= 1` as dictated by
line [26] in `Attack.sol`. 

10. *Attack.sol - Line [26]* - Once there less 1 (or less) ether left in the
`EtherStore` contract, this if statement will fail. This will then allow lines
[18] and [19] of the `EtherStore` contract to be executed (for each call to the
    `withdrawFunds()` function).

11. *EtherStore.sol - Lines [18] and [19]* - The `balances` and
`lastWithdrawTime` mappings will be set and the execution will end.

The final result, is that the attacker has withdrawn all (bar 1) ether
from the `EtherStore` contract, instantaneously with a single
transaction.

===== Preventative Techniques

There are a number of common techniques which help avoid potential
re-entrancy vulnerabilities in smart contracts. The first is to (
whenever possible) use the built-in
http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#address-related[transfer()]
function when sending ether to external contracts. The transfer function
only sends `2300 gas` with the external call, which is not enough for the destination
address/contract to call another contract (i.e. re-enter the sending
contract).

The second technique is to ensure that all logic that changes state
variables happen before ether is sent out of the contract (or any
external call). In the `EtherStore` example, lines [18] and [19] of
`EtherStore.sol` should be put before line [17]. It is good practice to
place any code that performs external calls to unknown addresses as the
last operation in a localised function or piece of code execution. This
is known as the
http://solidity.readthedocs.io/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions]
pattern.

A third technique is to introduce a mutex. That is, to add a state
variable which locks the contract during code execution, preventing
reentrancy calls.

Applying all of these techniques (all three are unnecessary, but is done
for demonstrative purposes) to `EtherStore.sol`, gives the
re-entrancy-free contract:

[source,solidity,linenums]
----
contract EtherStore {

    // initialise the mutex
    bool reEntrancyMutex = false;
    uint256 public withdrawalLimit = 1 ether;
    mapping(address => uint256) public lastWithdrawTime;
    mapping(address => uint256) public balances;
    
    function depositFunds() public payable {
        balances[msg.sender] += msg.value;
    }
    
    function withdrawFunds (uint256 _weiToWithdraw) public {
        require(!reEntrancyMutex);
        require(balances[msg.sender] >= _weiToWithdraw);
        // limit the withdrawal
        require(_weiToWithdraw <= withdrawalLimit);
        // limit the time allowed to withdraw
        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
        balances[msg.sender] -= _weiToWithdraw;
        lastWithdrawTime[msg.sender] = now;
        // set the reEntrancy mutex before the external call
        reEntrancyMutex = true;
        msg.sender.transfer(_weiToWithdraw);
        // release the mutex after the external call
        reEntrancyMutex = false; 
    }
 }
----

===== Real-World Example: The DAO

https://en.wikipedia.org/wiki/The_DAO_(organization)[The DAO]
(Decentralized Autonomous Organization) was one of the major hacks that
occurred in the early development of Ethereum. At the time, the contract
held over $150 million USD. Re-entrancy played a major role in the
attack which ultimately lead to the hard-fork that created Ethereum
Classic (ETC). For a good analysis of the DAO exploit, see
http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/[Phil
Daian’s post].

==== Arithmetic Over/Under Flows

The Ethereum Virtual Machine (EVM) specifies fixed-size data types for
integers. This means that an integer variable, only has a certain range
of numbers it can represent. A `uint8` for example, can only store
numbers in the range [0,255]. Trying to store `256` into a `uint8` will
result in `0`. If care is not taken, variables in Solidity can be
exploited if user input is unchecked and calculations are performed
which result in numbers that lie outside the range of the data type that
stores them.

For further reading on arithmetic over/under flows, see
https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d[How
to Secure Your Smart Contracts],
https://consensys.github.io/smart-contract-best-practices/known_attacks/#integer-overflow-and-underflow[Ethereum
Smart Contract Best Practices] and
https://randomoracle.wordpress.com/2018/04/27/ethereum-solidity-and-integer-overflows-programming-blockchains-like-1970/[Ethereum,
Solidity and integer overflows: programming blockchains like 1970]

===== The Vulnerability

An over/under flow occurs when an operation is performed that requires a
fixed size variable to store a number (or piece of data) that is outside
the range of the variable’s data type.

For example, subtracting `1` from a `uint8` (unsigned integer of 8 bits,
i.e. only positive) variable that stores `0` as it’s value, will result
in the number `255`. This is an underflow. We have assigned a number
below the range of the `uint8`, the result _wraps around_ and gives the
largest number a `uint8` can store. Similarly, adding `2^8=256` to a
`uint8` will leave the variable unchanged as we have wrapped around the
entire length of the `uint`. Two simple analogies of this behaviour are;
speedometers in cars which measure distance travelled (they restart to 0, after 
the largest number, i.e. 999999 is surpassed) and periodic mathematical functions
(adding 2*Pi to the argument of sin() leaves the value unchanged). 

Adding numbers larger than the data type’s range is called an overflow. For
clarity, adding `257` to a `uint8` that currently has a zero value will result
in the number `1`.  It is sometimes instructive to think of fixed type variables
being cyclic, where we start again from zero if we add numbers above the
largest possible stored number, and vice-versa for zero (where we start
counting down from the largest number the more we subtract from 0).

These kinds of numerical caveats allow attackers to misuse code and create
unexpected logic flows. For example, consider the time locking contract
below.

.TimeLock.sol:
[source,solidity,linenums]
----
contract TimeLock {
    
    mapping(address => uint) public balances;
    mapping(address => uint) public lockTime;
    
    function deposit() public payable {
        balances[msg.sender] += msg.value;
        lockTime[msg.sender] = now + 1 weeks;
    }
    
    function increaseLockTime(uint _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease;
    }
    
    function withdraw() public {
        require(balances[msg.sender] > 0);
        require(now > lockTime[msg.sender]);
        balances[msg.sender] = 0;
        msg.sender.transfer(balances[msg.sender]);
    }
}
----

This contract is designed to act like a time vault, where users can
deposit ether into the contract and it will be locked there for at least
a week. The user may extend the wait time to longer than 1 week if they choose,
but once deposited, the user can be sure their ether is locked in safely
for at least a week, or so this contract intends. 

In the event a user is forced to hand over their private key a contract such as
this may be handy to ensure ether is unobtainable in short periods of time. If
a user had locked in `100 ether` in this contract and handed their keys over to
an attacker, an attacker could use an overflow to receive the ether, regardless
of the `lockTime`.

The attacker could determine the current `lockTime` for the address they
now hold the key for (its a public variable). Let’s call this
`userLockTime`. They could then call the `increaseLockTime` function and
pass as an argument the number `2^256 - userLockTime`. This number would
be added to the current `userLockTime` and cause an overflow, resetting
`lockTime[msg.sender]` to `0`. The attacker could then simply call the
`withdraw` function to obtain their reward.

Let’s look at another example, this one from the
https://github.com/OpenZeppelin/ethernaut[Ethernaut Challanges].

*SPOILER ALERT:* _If you have not yet done the Ethernaut challenges, this
gives a solution to one of the levels_.

[source,solidity]
----
pragma solidity ^0.4.18;

contract Token {

  mapping(address => uint) balances;
  uint public totalSupply;

  function Token(uint _initialSupply) {
    balances[msg.sender] = totalSupply = _initialSupply;
  }

  function transfer(address _to, uint _value) public returns (bool) {
    require(balances[msg.sender] - _value >= 0);
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    return true;
  }

  function balanceOf(address _owner) public constant returns (uint balance) {
    return balances[_owner];
  }
}
----

This is a simple token contract which employs a `transfer()` function,
allowing participants to move their tokens around. Can you see the error
in this contract?

The flaw comes in the `transfer()` function. The require statement on
line [13] can be bypassed using an underflow. Consider a user that has
no balance. They could call the `transfer()` function with any non-zero
`_value` and pass the require statement on line [13]. This is because
`balances[msg.sender]` is zero (and a `uint256`) so subtracting any
positive amount (excluding `2^256`) will result in a positive number due
to the underflow we described above. This is also true for line [14],
where our balance will be credited with a positive number. Thus, in this
example, we have achieved free tokens due to an underflow vulnerability.

===== Preventative Techniques

The (currently) conventional technique to guard against under/overflow
vulnerabilities is to use or build mathematical libraries which replace
the standard math operators; addition, subtraction and multiplication
(division is excluded as it does not cause over/under flows and the EVM
reverts on division by 0).

https://github.com/OpenZeppelin/zeppelin-solidity[OppenZepplin] have
done a great job in building and auditing secure libraries which can be
leveraged by the Ethereum community. In particular, their
https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol[Safe
Math Library] is a reference or library to use to avoid under/over flow
vulnerabilities.

To demonstrate how these libraries are used in Solidity, let us correct
the `TimeLock` contract, using Open Zepplin’s `SafeMath` library. The
over flow-free contract would become:

[source,solidity,linenums]
----
library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b); 
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b; 
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

contract TimeLock {
    using SafeMath for uint; // use the library for uint type
    mapping(address => uint256) public balances;
    mapping(address => uint256) public lockTime;
    
    function deposit() public payable {
        balances[msg.sender] = balances[msg.sender].add(msg.value);
        lockTime[msg.sender] = now.add(1 weeks);
    }
    
    function increaseLockTime(uint256 _secondsToIncrease) public {
        lockTime[msg.sender] = lockTime[msg.sender].add(_secondsToIncrease);
    }
    
    function withdraw() public {
        require(balances[msg.sender] > 0);
        require(now > lockTime[msg.sender]);
        balances[msg.sender] = 0;
        msg.sender.transfer(balances[msg.sender]);
    }
}
----

Notice that all standard math operations have been replaced by the those
defined in the `SafeMath` library. The `TimeLock` contract no longer
performs any operation which is capable of doing an under/over flow.

===== Real-World Examples: PoWHC and Batch Transfer Overflow (CVE-2018–10299)

Proof of Weak Hands Coin (PoWHC), originally devised as a joke of sorts, was a
ponzi scheme written by an internet collective. Unfortunately it seems that the author(s) of the contract
had not seen over/under flows before and consequently, 866 ether was
liberated from its contract. A good overview of how the underflow occurs
(which is not too dissimilar to the Ethernaut challenge above) is given
in
https://blog.goodaudience.com/how-800k-evaporated-from-the-powh-coin-ponzi-scheme-overnight-1b025c33b530[Eric
Banisadar’s post].

Another example comes from the implementation of a `batchTransfer()` function
into a group of https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md[ERC20] token
contracts. The implementation contained an overflow.
https://medium.com/@peckshield/alert-new-batchoverflow-bug-in-multiple-erc20-smart-contracts-cve-2018-10299-511067db6536[This
post] details the overflow further, which now has it's own CVE
(https://www.cvedetails.com/cve/CVE-2018-10299/[CVE-2018–10299]).

==== Unexpected Ether

Typically when ether is sent to a contract, it must execute either the
fallback function, or another function described in the contract. There
are two exceptions to this, where ether can exist in a contract without
having executed any code. Contracts which rely on code execution for
every ether sent to the contract can be vulnerable to attacks where
ether is forcibly sent to a contract.

For further reading on this, see
https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-2-730db0aa4834[How
to Secure Your Smart Contracts: 6] and
http://danielszego.blogspot.com.au/2018/03/solidity-security-patterns-forcing.html[Solidity
security patterns - forcing ether to a contract].

===== The Vulnerability

A common defensive programming technique that is useful in enforcing
correct state transitions or validating operations is
_invariant-checking_. This technique involves defining a set of
invariants (metrics or parameters that should not change) and checking
these invariants remain unchanged after a single (or many) operation(s).
This is typically good design, provided the invariants being checked are
in fact invariants. One example of an invariant is the `totalSupply` of
a fixed issuance
https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md[ERC20]
token. As no functions should modify this invariant, one could add a
check to the `transfer()` function that ensures the `totalSupply`
remains unmodified to ensure the function is working as expected.

In particular, there is one apparent _invariant_, that may be tempting to use
but can in fact be manipulated by external users (regardless of the rules put
in place in the smart contract). This is the current ether stored in the
contract. Often when developers first learn Solidity they have the
misconception that a contract can only accept or obtain ether via payable
functions. This misconception can lead to contracts that have false assumptions
about the ether balance within them which can lead to a range of
vulnerabilities. The smoking gun for this vulnerability is the (incorrect) use
of `this.balance`. As we will see, incorrect uses of `this.balance` can lead to
serious vulnerabilities of this type.

There are two ways in which ether can (forcibly) be sent to a contract
without using a `payable` function or executing any code on the
contract. These are listed below.

Self Destruct / Suicide::

Any contract is able to implement the
http://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#self-destruct[`selfdestruct(address)`]
function, which removes all bytecode from the contract address and sends
all ether stored there to the parameter-specified address. If this
specified address is also a contract, no functions (including the
fallback) get called. Therefore, the `selfdestruct()` function can be
used to forcibly send ether to any contract regardless of any code that
may exist in the contract. This is inclusive of contracts without any
payable functions. This means, any attacker can create a contract with a
`selfdestruct()` function, send ether to it, call `selfdestruct(target)`
and force ether to be sent to a `target` contract. Martin Swende has an
excellent
http://martin.swende.se/blog/Ethereum_quirks_and_vulns.html[blog post]
describing some quirks of the self-destruct opcode (Quirk #2) along with
a description of how client nodes were checking incorrect invariants
which could have lead to a rather catastrophic crash of the Ethereum network. 

Pre-sent Ether::

The second way a contract can obtain ether without using a `selfdestruct()`
function or calling any payable functions is to pre-load the contract address
with ether. Contract addresses are deterministic, in fact the address is
calculated from the keccak256 (commonly synonymous with sha3) hash of the
address creating the contract and the transaction nonce which creates the
contract. Specifically, it is of the form: `address = sha3(rlp.encode([account_address,transaction_nonce]))` 
(see https://blog.sigmaprime.io/solidity-security.html#keyless-eth[Keyless Ether] for some fun use cases of this). This
means, anyone can calculate what a contract address will be before it is
created and thus send ether to that address. When the contract does get
created it will have a non-zero ether balance.

Let’s explore some pitfalls that can arise given the above knowledge.

Consider the overly-simple contract,

.EtherGame.sol:
[source,solidity,linenums]
----
contract EtherGame {
    
    uint public payoutMileStone1 = 3 ether;
    uint public mileStone1Reward = 2 ether;
    uint public payoutMileStone2 = 5 ether;
    uint public mileStone2Reward = 3 ether; 
    uint public finalMileStone = 10 ether; 
    uint public finalReward = 5 ether; 
    
    mapping(address => uint) redeemableEther;
    // users pay 0.5 ether. At specific milestones, credit their accounts
    function play() public payable {
        require(msg.value == 0.5 ether); // each play is 0.5 ether
        uint currentBalance = this.balance + msg.value;
        // ensure no players after the game as finished
        require(currentBalance <= finalMileStone);
        // if at a milestone credit the players account
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        return;
    }
    
    function claimReward() public {
        // ensure the game is complete
        require(this.balance == finalMileStone);
        // ensure there is a reward to give
        require(redeemableEther[msg.sender] > 0); 
        redeemableEther[msg.sender] = 0;
        msg.sender.transfer(redeemableEther[msg.sender]);
    }
 }    
----

This contract represents a simple game (which would naturally invoke
race-conditions) whereby players send `0.5 ether`
quanta to the contract in hope to be the player that reaches one of
three milestones first. Milestone’s are denominated in ether. The first
to reach the milestone may claim a portion of the ether when the game
has ended. The game ends when the final milestone (`10 ether`) is
reached and users can claim their rewards.

The issues with the `EtherGame` contract come from the poor use of
`this.balance` in both lines [14] (and by association [16]) and [32]. A
mischievous attacker could forcibly send a small amount of ether, let’s
say `0.1 ether` via the `selfdestruct()` function (discussed above) to
prevent any future players from reaching a milestone. As all legitimate
players can only send `0.5 ether` increments, `this.balance` would no
longer be half integer numbers, as it would also have the `0.1 ether`
contribution. This prevents all the if conditions on lines [18], [21]
and [24] from being true.

Even worse, a vengeful attacker who missed a milestone, could forcibly
send `10 ether` (or an equivalent amount of ether that pushes the
contract’s balance above the `finalMileStone`) which would lock all
rewards in the contract forever. This is because the `claimReward()`
function will always revert, due to the require on line [32] (i.e.
`this.balance` is greater than `finalMileStone`).

===== Preventative Techniques

This vulnerability typically arises from the misuse of `this.balance`.
Contract logic, when possible, should avoid being dependent on exact
values of the balance of the contract because it can be artificially
manipulated. If applying logic based on `this.balance`, ensure to
account for unexpected balances.

If exact values of deposited ether are required, a self-defined variable
should be used that gets incremented in payable functions, to safely
track the deposited ether. This variable will not be influenced by the
forced ether sent via a `selfdestruct()` call.

With this in mind, a corrected version of the `EtherGame` contract could
look like:

[source,solidity,linenums]
----
contract EtherGame {
    
    uint public payoutMileStone1 = 3 ether;
    uint public mileStone1Reward = 2 ether;
    uint public payoutMileStone2 = 5 ether;
    uint public mileStone2Reward = 3 ether; 
    uint public finalMileStone = 10 ether; 
    uint public finalReward = 5 ether; 
    uint public depositedWei;
    
    mapping (address => uint) redeemableEther;
    
    function play() public payable {
        require(msg.value == 0.5 ether);
        uint currentBalance = depositedWei + msg.value;
        // ensure no players after the game as finished
        require(currentBalance <= finalMileStone);
        if (currentBalance == payoutMileStone1) {
            redeemableEther[msg.sender] += mileStone1Reward;
        }
        else if (currentBalance == payoutMileStone2) {
            redeemableEther[msg.sender] += mileStone2Reward;
        }
        else if (currentBalance == finalMileStone ) {
            redeemableEther[msg.sender] += finalReward;
        }
        depositedWei += msg.value;
        return;
    }
    
    function claimReward() public {
        // ensure the game is complete
        require(depositedWei == finalMileStone);
        // ensure there is a reward to give
        require(redeemableEther[msg.sender] > 0); 
        redeemableEther[msg.sender] = 0;
        msg.sender.transfer(redeemableEther[msg.sender]);
    }
 }    
----

Here, we have just created a new variable, `depositedEther` which keeps
track of the known ether deposited, and it is this variable to which we
perform our requirements and tests. Notice, that we no longer have any
reference to `this.balance`.

===== Further Examples: 

A few examples of exploitable contracts were given in the
https://github.com/Arachnid/uscc/tree/master/submissions-2017/[Underhanded
Solidity Contest], which also provides extended examples of a number of the
pitfalls raised in this section. 

==== Delegatecall

The `CALL` and `DELEGATECALL` opcodes are useful in allowing Ethereum
developers to modularise their code. Standard external message calls to
contracts are handled by the `CALL` opcode whereby code is run in the
context of the external contract/function. The `DELEGATECALL` opcode is
identical to the standard message call, except that the code executed at
the targeted address is run in the context of the calling contract along
with the fact that `msg.sender` and `msg.value` remain unchanged. This
feature enables the implementation of _libraries_ whereby developers can
create reusable code for future contracts.

Although the differences between these two opcodes are simple and
intuitive, the use of `DELEGATECALL` can lead to unexpected code
execution.

For further reading, see
https://ethereum.stackexchange.com/questions/3667/difference-between-call-callcode-and-delegatecall[Ethereum
Stack Exchange Question],
http://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries[Solidity
Docs] and
https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d[How
to Secure Your Smart Contracts: 6].

===== The Vulnerability

The context preserving nature of `DELEGATECALL` has proved that building
vulnerability-free custom libraries is not as easy as one might think.
The code in libraries themselves can be secure and vulnerability-free
however when run in the context of another application new
vulnerabilities can arise. Let’s see a fairly complex example of this,
using Fibonacci numbers.

Consider the following library which can generate the Fibonacci sequence
and sequences of similar form footnote:[This code was
modified from
https://github.com/web3j/web3j/blob/master/codegen/src/test/resources/solidity/fibonacci/Fibonacci.sol[web3j]].

.FibonacciLib.sol
[source,solidity,linenums]
----
// library contract - calculates fibonacci-like numbers;
contract FibonacciLib {
    // initializing the standard fibonacci sequence;
    uint public start;
    uint public calculatedFibNumber;

    // modify the zeroth number in the sequence
    function setStart(uint _start) public {
        start = _start;
    }

    function setFibonacci(uint n) public {
        calculatedFibNumber = fibonacci(n);
    }

    function fibonacci(uint n) internal returns (uint) {
        if (n == 0) return start;
        else if (n == 1) return start + 1;
        else return fibonacci(n - 1) + fibonacci(n - 2);
    }
}
----

This library provides a function which can generate the _n_-th Fibonacci
number in the sequence. It allows users to change the starting number of the
sequence (`start`) and calculate the _n_-th Fibonacci-like numbers in this new
sequence.

Let us now consider a contract that utilises this library.

.FibonacciBalance.sol:
[source,solidity,linenums]
----
contract FibonacciBalance {

    address public fibonacciLibrary;
    // the current fibonacci number to withdraw
    uint public calculatedFibNumber;
    // the starting fibonacci sequence number
    uint public start = 3;    
    uint public withdrawalCounter;
    // the fibonancci function selector
    bytes4 constant fibSig = bytes4(sha3("setFibonacci(uint256)"));
    
    // constructor - loads the contract with ether
    constructor(address _fibonacciLibrary) public payable {
        fibonacciLibrary = _fibonacciLibrary;
    }

    function withdraw() {
        withdrawalCounter += 1;
        // calculate the fibonacci number for the current withdrawal user
        // this sets calculatedFibNumber
        require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));
        msg.sender.transfer(calculatedFibNumber * 1 ether);
    }
    
    // allow users to call fibonacci library functions
    function() public {
        require(fibonacciLibrary.delegatecall(msg.data));
    }
}
----

This contract allows a participant to withdraw ether from the contract,
with the amount of ether being equal to the Fibonacci number
corresponding to the participants withdrawal order; i.e., the first
participant gets 1 ether, the second also gets 1, the third gets 2, the
forth gets 3, the fifth 5 and so on (until the balance of the contract
is less than the Fibonacci number being withdrawn).

// TODO: Andreas to decide if this into is necessary, or to simple refer to
// another section of the book.

There are a number of elements in this contract that may require some
explanation. Firstly, there is an interesting-looking variable,
`fibSig`. This holds the first 4 bytes of the Keccak (SHA-3) hash of the
string `'setFibonacci(uint256)'`. This is known as the
https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector[function
selector] and is put into `calldata` to specify which function of a
smart contract will be called. It is used in the `delegatecall` function
on line [21] to specify that we wish to run the `fibonacci(uint256)`
function. The second argument in `delegatecall` is the parameter we are
passing to the function. Secondly, we assume that the address for the
`FibonacciLib` library is correctly referenced in the constructor
(section *External Contract Referencing* discusses some
potential vulnerabilities relating to this kind if contract reference
initialisation).

Can you spot any error(s) in this contract? If one were to deploy this contract,
fill it with ether and call `withdraw()`, it will likely revert.

You may have noticed that the state variable `start` is used in both the
library and the main calling contract. In the library contract, `start`
is used to specify the beginning of the Fibonacci sequence and is set to
`0`, whereas it is set to `3` in the `FibonacciBalance` contract. You
may also have noticed that the fallback function in the
`FibonacciBalance` contract allows all calls to be passed to the library
contract, which allows for the `setStart()` function of the library
contract to be called also. Recalling that we preserve the state of the
contract, it may seem that this function would allow you to change the
state of the `start` variable in the local `FibonnacciBalance` contract.
If so, this would allow one to withdraw more ether, as the resulting
`calculatedFibNumber` is dependent on the `start` variable (as seen in
the library contract). In actual fact, the `setStart()` function does
not (and cannot) modify the `start` variable in the `FibonacciBalance`
contract. The underlying vulnerability in this contract is significantly
worse than just modifying the `start` variable.

// TODO: Andreas to decide if this into is necessary, or to simple refer to
// another section of the book.

Before discussing the actual issue, we take a quick detour to
understanding how state variables (`storage` variables) actually get
stored in contracts. State or `storage` variables (variables that
persist over individual transactions) are placed into `slots`
sequentially as they are introduced in the contract. (There are some
complexities here, and the reader is encouraged to read
http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage[Layout
of State Variables in Storage] for a more thorough understanding).

As an example, let’s look at the library contract. It has two state
variables, `start` and `calculatedFibNumber`. The first variable is
`start`, as such it gets stored into the contract’s storage at `slot[0]`
(i.e. the first slot). The second variable, `calculatedFibNumber`, gets
placed in the next available storage slot, `slot[1]`. If we look at the
function `setStart()`, it takes an input and sets `start` to whatever
the input was. This function is therefore setting `slot[0]` to whatever
input we provide in the `setStart()` function. Similarly, the
`setFibonacci()` function sets `calculatedFibNumber` to the result of
`fibonacci(n)`. Again, this is simply setting storage `slot[1]` to the
value of `fibonacci(n)`.

Now lets look at the `FibonacciBalance` contract. Storage `slot[0]` now
corresponds to `fibonacciLibrary` address and `slot[1]` corresponds to
`calculatedFibNumber`. It is in this incorrect mapping that the vulnerability occurs.
`delegatecall` *preserves contract context*. This means that code that
is executed via `delegatecall` will act on the state (i.e. storage) of
the calling contract.

Now notice that in `withdraw()` on line [21] we execute,
`fibonacciLibrary.delegatecall(fibSig,withdrawalCounter)`. This calls
the `setFibonacci()` function, which as we discussed, modifies storage
`slot[1]`, which in our current context is `calculatedFibNumber`. This
is as expected (i.e. after execution, `calculatedFibNumber` gets
adjusted). However, recall that the `start` variable in the
`FibonacciLib` contract is located in storage `slot[0]`, which is the
`fibonacciLibrary` address in the current contract. This means that the
function `fibonacci()` will give an unexpected result. This is because
it references `start` (`slot[0]`) which in the current calling context
is the `fibonacciLibrary` address (which will often be quite large, when
interpreted as a `uint`). Thus it is likely that the `withdraw()`
function will revert as it will not contain `uint(fibonacciLibrary)`
amount of ether, which is what `calculatedFibNumber` will return.

Even worse, the `FibonacciBalance` contract allows users to call all of
the `fibonacciLibrary` functions via the fallback function on line [26].
As we discussed earlier, this includes the `setStart()` function. We
discussed that this function allows anyone to modify or set storage
`slot[0]`. In this case, storage `slot[0]` is the `fibonacciLibrary`
address. Therefore, an attacker could create a malicious contract (an
example of one is given below), convert the address to a `uint` (this can be
done in python easily using `int('<address>',16)`) and then call
`setStart(<attack_contract_address_as_uint>)`. This will change
`fibonacciLibrary` to the address of the attack contract. Then, whenever
a user calls `withdraw()` or the fallback function, the malicious
contract will run (which can steal the entire balance of the contract)
because we’ve modified the actual address for `fibonacciLibrary`. An
example of such an attack contract would be,

[source,solidity,linenums]
----
contract Attack {
    uint storageSlot0; // corresponds to fibonacciLibrary
    uint storageSlot1; // corresponds to calculatedFibNumber
   
    // fallback - this will run if a specified function is not found
    function() public {
        storageSlot1 = 0; // we set calculatedFibNumber to 0, so that if withdraw
        // is called we don't send out any ether. 
        <attacker_address>.transfer(this.balance); // we take all the ether
    }
 }
----

Notice that this attack contract modifies the `calculatedFibNumber` by
changing storage `slot[1]`. In principle, an attacker could modify any
other storage slots they choose to perform all kinds of attacks on this
contract. I encourage all readers to put these contracts into
https://remix.ethereum.org[Remix] and experiment with different attack
contracts and state changes through these `delegatecall` functions.

It is also important to notice that when we say that `delegatecall` is
state-preserving, we are not talking about the variable names of the
contract, rather the actual storage slots to which those names point. As
you can see from this example, a simple mistake, can lead to an attacker
hijacking the entire contract and its ether.

===== Preventative Techniques

Solidity provides the `library` keyword for implementing library
contracts (see the
http://solidity.readthedocs.io/en/latest/contracts.html?highlight=library#libraries[Solidity
Docs] for further details). This ensures the library contract is
stateless and non-self-destructable. Forcing libraries to be stateless
mitigates the complexities of storage context demonstrated in this
section. Stateless libraries also prevent attacks whereby attackers
modify the state of the library directly in order to effect the
contracts that depend on the library’s code. As a general rule of thumb,
when using `DELEGATECALL` pay careful attention to the possible calling
context of both the library contract and the calling contract, and
whenever possible, build state-less libraries.

===== Real-World Example: Parity Multisig Wallet (Second Hack)

The Second Parity Multisig Wallet hack is an example of how the context
of well-written library code can be exploited if run in its non-intended
context. There are a number of good explanations of this hack, such as
this overview:
https://medium.com/chain-cloud-company-blog/parity-multisig-hack-again-b46771eaa838[Parity
MultiSig Hacked. Again] by Anthony Akentiev, this
https://ethereum.stackexchange.com/questions/30128/explanation-of-parity-library-suicide/30130[stack
exchange question] and
http://hackingdistributed.com/2017/07/22/deep-dive-parity-bug/[An
In-Depth Look at the Parity Multisig Bug].

To add to these references, let’s explore the contracts that were
exploited. The library and wallet contract can be found on the parity
github
https://github.com/paritytech/parity/blob/b640df8fbb964da7538eef268dffc125b081a82f/js/src/contracts/snippets/enhanced-wallet.sol[here].

Let’s look at the relevant aspects of this contract. There are two
contracts of interest contained here, the library contract and the
wallet contract.

The library contract,

[source,solidity,linenums]
----
contract WalletLibrary is WalletEvents {
  
  ...
  
  // throw unless the contract is not yet initialized.
  modifier only_uninitialized { if (m_numOwners > 0) throw; _; }

  // constructor - just pass on the owner array to the multiowned and
  // the limit to daylimit
  function initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized {
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }

  // kills the contract sending everything to `_to`.
  function kill(address _to) onlymanyowners(sha3(msg.data)) external {
    suicide(_to);
  }
  
  ...
  
}
----

and the wallet contract,

[source,solidity,linenums]
----
contract Wallet is WalletEvents {

  ...

  // METHODS

  // gets called when no other function matches
  function() payable {
    // just being sent some cash?
    if (msg.value > 0)
      Deposit(msg.sender, msg.value);
    else if (msg.data.length > 0)
      _walletLibrary.delegatecall(msg.data);
  }
  
  ...  

  // FIELDS
  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;
}
----

Notice that the `Wallet` contract essentially passes all calls to the
`WalletLibrary` contract via a delegate call. The constant
`_walletLibrary` address in this code snippet acts as a placeholder for
the actually deployed `WalletLibrary` contract (which was at
`0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4`).

The intended operation of these contracts was to have a simple low-cost
deployable `Wallet` contract whose code base and main functionality was
in the `WalletLibrary` contract. Unfortunately, the `WalletLibrary`
contract is itself a contract and maintains it’s own state. Can you see
why this might be an issue?

It is possible to send calls to the `WalletLibrary` contract itself.
Specifically, the `WalletLibrary` contract could be initialised, and
become owned. A user did this, by calling `initWallet()` function on the
`WalletLibrary` contract, becoming an owner of the library contract. The
same user, subsequently called the `kill()` function. Because the user
was an owner of the Library contract, the modifier passed and the
library contract suicided. As all `Wallet` contracts in existence refer
to this library contract and contain no method to change this reference,
all of their functionality, including the ability to withdraw ether is
lost along with the `WalletLibrary` contract. More directly, all ether
in all parity multi-sig wallets of this type instantly become lost or
permanently unrecoverable.

==== Default Visibilities

Functions in Solidity have visibility specifiers which dictate how
functions are allowed to be called. The visibility determines whether a
function can be called externally by users, by other derived contracts,
only internally or only externally. There are four visibility
specifiers, which are described in detail in the
http://solidity.readthedocs.io/en/latest/contracts.html?highlight=library#visibility-and-getters[Solidity
Docs]. Functions default to `public` allowing users to call them
externally. Incorrect use of visibility specifiers can lead to some
devestating vulernabilities in smart contracts as will be discussed in
this section.

===== The Vulnerability

The default visibility for functions is `public`. Therefore functions
that do not specify any visibility will be callable by external users.
The issue comes when developers mistakenly ignore visibility specifiers
on functions which should be private (or only callable within the
contract itself).

Lets quickly explore a trivial example.

[source,solidity,linenums]
----
contract HashForEther {
    
    function withdrawWinnings() {
        // Winner if the last 8 hex characters of the address are 0. 
        require(uint32(msg.sender) == 0);
        _sendWinnings();
     }
     
     function _sendWinnings() {
         msg.sender.transfer(this.balance);
     }
}
----

This simple contract is designed to act as an address guessing bounty
game. To win the balance of the contract, a user must generate an
Ethereum address whose last 8 hex characters are 0. Once obtained, they
can call the `WithdrawWinnings()` function to obtain their bounty.

Unfortunately, the visibility of the functions have not been specified.
In particular, the `_sendWinnings()` function is `public` and thus any
address can call this function to steal the bounty.

===== Preventative Techniques

It is good practice to always specify the visibility of all functions in
a contract, even if they are intentionally `public`. Recent versions of
Solidity will now show warnings during compilation for functions that
have no explicit visibility set, to help encourage this practice.

===== Real-World Example: Parity MultiSig Wallet (First Hack)

In the first Parity multi-sig hack, about $31M worth of Ether was stolen
from primarily three wallets. A good recap of exactly how this was done
is given by Haseeb Qureshi in
https://medium.freecodecamp.org/a-hacker-stole-31m-of-ether-how-it-happened-and-what-it-means-for-ethereum-9e5dc29e33ce[this
post].

Essentially, the multi-sig wallet (which can be found
https://github.com/paritytech/parity/blob/4d08e7b0aec46443bf26547b17d10cb302672835/js/src/contracts/snippets/enhanced-wallet.sol[here])
is constructed from a base `Wallet` contract which calls a library
contract containing the core functionality (as was described in
the *Real-World Example: Parity Multisig (Second Hack)* section).
The library contract contains the code to initialise the wallet as can
be seen from the following snippet

[source,solidity,linenums]
----
contract WalletLibrary is WalletEvents {
  
  ... 
  
  // METHODS

  ...
  
  // constructor is given number of sigs required to do protected "onlymanyowners" transactions
  // as well as the selection of addresses capable of confirming them.
  function initMultiowned(address[] _owners, uint _required) {
    m_numOwners = _owners.length + 1;
    m_owners[1] = uint(msg.sender);
    m_ownerIndex[uint(msg.sender)] = 1;
    for (uint i = 0; i < _owners.length; ++i)
    {
      m_owners[2 + i] = uint(_owners[i]);
      m_ownerIndex[uint(_owners[i])] = 2 + i;
    }
    m_required = _required;
  }

  ...

  // constructor - just pass on the owner array to the multiowned and
  // the limit to daylimit
  function initWallet(address[] _owners, uint _required, uint _daylimit) {
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }
}
----

Notice that neither of the functions have explicitly specified a
visibility. Both functions default to `public`. The `initWallet()`
function is called in the wallets constructor and sets the owners for
the multi-sig wallet as can be seen in the `initMultiowned()` function.
Because these functions were accidentally left `public`, an attacker was
able to call these functions on deployed contracts, resetting the
ownership to the attackers address. Being the owner, the attacker then
drained the wallets of all their ether, to the tune of $31M.

==== Entropy Illusion

All transactions on the Ethereum blockchain are deterministic state
transition operations. Meaning that every transaction modifies the
global state of the Ethereum ecosystem and it does so in a calculable
way with no uncertainty. This ultimately means that inside the
blockchain ecosystem there is no source of entropy or randomness. There
is no `rand()` function in Solidity. Achieving decentralised entropy
(randomness) is a well established problem and many ideas have been
proposed to address this (see for example,
https://github.com/randao/randao[RandDAO] or using a chain of Hashes as
described by Vitalik in this
https://vitalik.ca/files/randomness.html[post]).

===== The Vulnerability

Some of the first contracts built on the Ethereum platform were based
around gambling. Fundamentally, gambling requires uncertainty (something
to bet on), which makes building a gambling system on the blockchain (a
deterministic system) rather difficult. It is clear that the uncertainty
must come from a source external to the blockchain. This is possible for
bets amongst peers (see for example the
https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract[commit-reveal
technique]), however, it is significantly more difficult if you want to
implement a contract to act as _the house_ (like in blackjack our
roulette). A common pitfall is to use future block variables, such as
hashes, timestamps, blocknumber or gas limit. The issue with these are
that they are controlled by the miner who mines the block and as such
are not truly random. Consider, for example, a roulette smart contract
with logic that returns a black number if the next block hash ends in an
even number. A miner (or miner pool) could bet $1M on black. If they
solve the next block and find the hash ends in an odd number, they would
happily not publish their block and mine another until they find a
solution with the block hash being an even number (assuming the block
reward and fees are less than $1M). Using past or present variables can
be even more devastating as Martin Swende demonstrates in his excellent
http://martin.swende.se/blog/Breaking_the_house.html[blog post].
Furthermore, using solely block variables mean that the pseudo-random
number will be the same for all transactions in a block, so an attacker
can multiply their wins by doing many transactions within a block
(should there be a maximum bet).

===== Preventative Techniques

The source of entropy (randomness) must be external to the blockchain.
This can be done amongst peers with systems such as
https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract[commit-reveal],
or via changing the trust model to a group of participants (such as in
https://github.com/randao/randao[RandDAO]). This can also be done via a
centralised entity, which acts as a randomness oracle. Block variables
(in general, there are some exceptions) should not be used to source
entropy as they can be manipulated by miners.

===== Real-World Example: PRNG Contracts

Arseny Reutov wrote a
https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620[blog
post] after he analysed 3649 live smart contracts which were using some
sort of pseudo random number generator (PRNG) and found 43 contracts
which could be exploited. 

==== External Contract Referencing

One of the benefits of the Ethereum _global computer_ is the ability to
re-use code and interact with contracts already deployed on the network.
As a result, a large number of contracts reference external contracts
and in general operation use external message calls to interact with
these contracts. These external message calls can mask malicious actors
intentions in some non-obvious ways, which will be discussed in this section.

===== The Vulnerability

In Solidity, any address can be cast as a contract regardless of whether
the code at the address represents the contract type being cast. This
can be deceiving, especially when the author of the contract is trying
to hide malicious code. Let us illustrate this with an example:

Consider a piece of code which rudimentarily implements the
link:www.wikipedia.com/rot13[Rot13] cipher.

.Rot13Encryption.sol:
[source,solidity,linenums]
----
//encryption contract
contract Rot13Encryption {
     
   event Result(string convertedString);
   
    //rot13 encrypt a string
    function rot13Encrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i < length; i++) {
            byte char = bytes(text)[i];
            //inline assembly to modify the string
            assembly {
                char := byte(0,char) // get the first byte
                if and(gt(char,0x6D), lt(char,0x7B)) // if the character is in [n,z], i.e. wrapping. 
                { char:= sub(0x60, sub(0x7A,char)) } // subtract from the ascii number a by the difference char is from z. 
                if iszero(eq(char, 0x20)) // ignore spaces
                {mstore8(add(add(text,0x20), mul(i,1)), add(char,13))} // add 13 to char. 
            }
        }
        emit Result(text);
    }
    
    // rot13 decrypt a string
    function rot13Decrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i < length; i++) {
            byte char = bytes(text)[i];
            assembly {
                char := byte(0,char)
                if and(gt(char,0x60), lt(char,0x6E))
                { char:= add(0x7B, sub(char,0x61)) }
                if iszero(eq(char, 0x20))
                {mstore8(add(add(text,0x20), mul(i,1)), sub(char,13))}
            }
        }
        emit Result(text);
    }
}
----

This code simply takes a string (letters a-z, without validation) and
_encrypts_ it by shifting each character 13 places to the right (wrapping
around `z`); i.e. `a` shifts to `n` and `x` shifts to `k`. The assembly
in the above contract does not need to be understood to appreciate the issue
being discussed, so the reader unfamiliar with assembly can safely ignore it.  

Consider the following contract which uses this code for its encryption,

[source,solidity,linenums]
----
import "Rot13Encryption.sol";

// encrypt your top secret info
contract EncryptionContract {
    // library for encryption
    Rot13Encryption encryptionLibrary;
        
    // constructor - initialise the library
    constructor(Rot13Encryption _encryptionLibrary) {
        encryptionLibrary = _encryptionLibrary;
    }
    
    function encryptPrivateData(string privateInfo) {
        // potentially do some operations here
        encryptionLibrary.rot13Encrypt(privateInfo);
     }
 }
----

The issue with this contract is that the `encryptionLibrary` address is
not public or constant. Thus the deployer of the contract could have
given an address in the constructor which points to this contract:

[source,solidity,linenums]
----
//encryption contract
contract Rot26Encryption {
     
   event Result(string convertedString);
   
    //rot13 encrypt a string
    function rot13Encrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i < length; i++) {
            byte char = bytes(text)[i];
            //inline assembly to modify the string
            assembly {
                char := byte(0,char) // get the first byte
                if and(gt(char,0x6D), lt(char,0x7B)) // if the character is in [n,z], i.e. wrapping. 
                { char:= sub(0x60, sub(0x7A,char)) } // subtract from the ascii number a by the difference char is from z. 
                if iszero(eq(char, 0x20)) // ignore spaces
                {mstore8(add(add(text,0x20), mul(i,1)), add(char,26))} // add 13 to char. 
            }
        }
        emit Result(text);
    }
    
    // rot13 decrypt a string
    function rot13Decrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i < length; i++) {
            byte char = bytes(text)[i];
            assembly {
                char := byte(0,char)
                if and(gt(char,0x60), lt(char,0x6E))
                { char:= add(0x7B, sub(char,0x61)) }
                if iszero(eq(char, 0x20))
                {mstore8(add(add(text,0x20), mul(i,1)), sub(char,26))}
            }
        }
        emit Result(text);
    }
}
----

which implements the rot26 cipher, which shifts each character by 26 places
(i.e. does nothing). Again, there is no need to understand the assembly in this
contract. A more elegant deployer could have also linked the following simpler
contract to the same effect:

[source,solidity,linenums]
----
contract Print{
    event Print(string text);
    
    function rot13Encrypt(string text) public {
        emit Print(text);
    }
 }
----

If the address of either of these contracts were given in the
constructor, the `encryptPrivateData()` function would simply produce an
event which prints the unencrypted private data. Although in this
example a library-like contract was set in the constructor, it is often
the case that a privileged user (such as an `owner`) can change library
contract addresses. If a linked contract doesn’t contain the function
being called, the fallback function will execute. For example, with the
line `encryptionLibrary.rot13Encrypt()`, if the contract specified by
`encryptionLibrary` was:

[source,solidity,linenums]
----
 contract Blank {
     event Print(string text);
     function () {
         emit Print("Here");
         //put malicious code here and it will run
     }
 }
----

then an event with the text `Here` would be emitted. Thus if users can
alter contract libraries, they can in principle get users to unknowingly
run arbitrary code.

_Note: The contracts represented here are for demonstrative purposes only and
do not represent actual encryption. These should not be implemented for any
kind of serious encryption._ 

===== Preventative Techniques

As demonstrated above, vulnerability free contracts can (in some cases)
be deployed in such a way that they behave maliciously. An auditor could
publicly verify a contract and have it’s owner deploy it in a malicious
way, resulting in a publicly audited contract which has vulnerabilities
or malicious intent.

There are a number of techniques which prevent these scenarios.

One technique, is to use the `new` keyword to create contracts. In the
example above, the constructor could be written like:

[source,solidity]
----
    constructor() {
        encryptionLibrary = new Rot13Encryption();
    }
----

This way an instance of the referenced contract is created at deployment
time and the deployer cannot replace the `Rot13Encryption` contract with
anything else without modifying the smart contract.

Another solution is to hard code any external contract addresses if they
are known.

In general, code that calls external contracts should always be looked
at carefully. As a developer, when defining external contracts, it can
be a good idea to make the contract addresses public (which is not the
case in the honey-pot example given below) to allow users to easily examine which
code is being referenced by the contract. Conversely, if a contract has
a private variable contract address it can be a sign of someone behaving
maliciously (as shown in the real-world example). If a privileged (or
any) user is capable of changing a contract address which is used to
call external functions, it can be important (in a decentralised system
context) to implement a time-lock or voting mechanism to allow users to
see which code is being changed or to give participants a chance to opt
in/out with the new contract address.

===== Real-World Example: Re-Entrancy Honey Pot

A number of recent honey pots have been released on the mainnet. These
contracts try to outsmart Ethereum hackers who try to exploit the
contracts, but who in turn end up getting ether lost to the contract
they expect to exploit. One example employs the above attack by
replacing an expected contract with a malicious one in the constructor.
The code can be found
https://etherscan.io/address/0x95d34980095380851902ccd9a1fb4c813c2cb639#code[here]:

[source,solidity,linenums]
----
pragma solidity ^0.4.19;

contract Private_Bank
{
    mapping (address => uint) public balances;
    uint public MinDeposit = 1 ether;
    Log TransferLog;
    
    function Private_Bank(address _log)
    {
        TransferLog = Log(_log);
    }
    
    function Deposit()
    public
    payable
    {
        if(msg.value >= MinDeposit)
        {
            balances[msg.sender]+=msg.value;
            TransferLog.AddMessage(msg.sender,msg.value,"Deposit");
        }
    }
    
    function CashOut(uint _am)
    {
        if(_am<=balances[msg.sender])
        {
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,"CashOut");
            }
        }
    }
    
    function() public payable{}    
    
}

contract Log 
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    
    Message[] public History;
    Message LastMsg;
    
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}
----

This
https://www.reddit.com/r/ethdev/comments/7x5rwr/tricked_by_a_honeypot_contract_or_beaten_by/[post]
by one reddit user explains how they lost 1 ether to this contract
by trying to exploit the re-entrancy bug they expected to be present in the
contract.

==== Short Address/Parameter Attack

This attack is not specifically performed on Solidity contracts
themselves but on third party applications that may interact with them. This
section is added for completeness and to give the reader an awareness of how parameters can be
manipulated in contracts.

For further reading, see
https://vessenes.com/the-erc20-short-address-attack-explained/[The ERC20
Short Address Attack Explained],
https://medium.com/huzzle/ico-smart-contract-vulnerability-short-address-attack-31ac9177eb6b[ICO
Smart contract Vulnerability: Short Address Attack] or this
https://www.reddit.com/r/ethereum/comments/6r9nhj/cant_understand_the_erc20_short_address_attack/[reddit
post].

===== The Vulnerability

When passing parameters to a smart contract, the parameters are encoded
according to the
https://solidity.readthedocs.io/en/latest/abi-spec.html[ABI
specification]. It is possible to send encoded parameters that are
shorter than the expected parameter length (for example, sending an
address that is only 38 hex chars (19 bytes) instead of the standard 40
hex chars (20 bytes)). In such a scenario, the EVM will pad 0’s to the
end of the encoded parameters to make up the expected length.

This becomes an issue when third party applications do not validate
inputs. The clearest example is an exchange which doesn’t verify the
address of an
https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md[ERC20] token
when a user requests a withdrawal. This example is covered in more
detail in Peter Venesses’ post,
http://vessenes.com/the-erc20-short-address-attack-explained/[The ERC20
Short Address Attack Explained] mentioned above.

Consider, the standard
https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md[ERC20]
transfer function interface, noting the order of the parameters,

[source,solidity]
----
function transfer(address to, uint tokens) public returns (bool success);
----

Now consider, an exchange, holding a large amount of a token (let’s say
`REP`) and a user wishes to withdraw their share of 100 tokens. The user
would submit their address, `0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddead`
and the number of tokens, `100`. The exchange would encode these
parameters in the order specified by the `transfer()` function, i.e.
`address` then `tokens`. The encoded result would be
`a9059cbb000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeaddead0000000000000`
`000000000000000000000000000000000056bc75e2d63100000`. The first four
bytes (`a9059cbb`) are the `transfer()`
https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector[function
signature/selector], the second 32 bytes are the address, followed by
the final 32 bytes which represent the `uint256` number of tokens.
Notice that the hex `56bc75e2d63100000` at the end corresponds to 100
tokens (with 18 decimal places, as specified by the `REP` token
contract).

Let us now look at what happens if one were to send an address that
was missing 1 byte (2 hex digits). Specifically, let’s say an attacker
sends `0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde` as an address (missing
the last two digits) and the same `100` tokens to withdraw. If the
exchange does not validate this input, it would get encoded as
`a9059cbb000000000000000000000000deaddeaddeaddeaddeaddeaddeaddeaddeadde00000000000000`
`00000000000000000000000000000000056bc75e2d6310000000`. The difference
is subtle. Note that `00` has been padded to the end of the encoding, to
make up for the short address that was sent. When this gets sent to the
smart contract, the `address` parameters will read as
`0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde00` and the value will be read
as `56bc75e2d6310000000` (notice the two extra `0`’s). This value is
now, `25600` tokens (the value has been multiplied by `256`). In this
example, if the exchange held this many tokens, the user would withdraw
`25600` tokens (whilst the exchange thinks the user is only withdrawing
`100`) to the modified address. Obviously the attacker wont possess the
modified address in this example, but if the attacker where to generate
any address which ended in `0`’s (which can be easily brute forced) and
used this generated address, they could easily steal tokens from the
unsuspecting exchange.

===== Preventative Techniques

All input parameters in external applications should be validated before
sending them to the blockchain. It should
also be noted that parameter ordering plays an important role here. As padding
only occurs at the end, careful ordering of parameters in the smart contract
can potentially mitigate some forms of this attack.

==== Unchecked CALL Return Values

There a number of ways of performing external calls in solidity. Sending
ether to external accounts is commonly performed via the `transfer()` method.
However, the `send()` function can also be used and, for more versatile
external calls, the `CALL` opcode can be directly employed in solidity.
The `call()` and `send()` functions return a boolean indicating if the
call succeeded or failed. Thus these functions have a simple caveat, in
that the transaction that executes these functions will not revert if
the external call (intialised by `call()` or `send()`) fails, rather the
`call()` or `send()` will simply return `false`. A common pitfall arises
when the return value is not checked, rather the developer expects a
revert to occur.

For further reading, see http://www.dasp.co/#item-4[DASP Top 10] and
http://hackingdistributed.com/2016/06/16/scanning-live-ethereum-contracts-for-bugs/[Scanning
Live Ethereum Contracts for the ``Unchecked-Send'' Bug].

===== The Vulnerability

Consider the following example:

[source,solidity,linenums]
----
contract Lotto {

    bool public payedOut = false;
    address public winner;
    uint public winAmount;
    
    // ... extra functionality here 

    function sendToWinner() public {
        require(!payedOut);
        winner.send(winAmount);
        payedOut = true;
    }
    
    function withdrawLeftOver() public {
        require(payedOut);
        msg.sender.send(this.balance);
    }
}
----

This contract represents a Lotto-like contract, where a `winner`
receives `winAmount` of ether, which typically leaves a little left over
for anyone to withdraw.

The vulnerability exists on line [11] where a `send()` is used without checking
the response. In this trivial example, a `winner` whose transaction
fails (either by running out of gas or being a contract that intentionally
throws in the fallback function) allows `payedOut` to be set to `true` (regardless
of whether ether was sent or not). In this case, the public can withdraw
the `winner`’s winnings via the `withdrawLeftOver()` function.

===== Preventative Techniques

Whenever possible, use the `transfer()` function rather than `send()` as
`transfer()` will `revert` if the external transaction reverts. If
`send()` is required, always ensure to check the return value.

An even more robust
http://solidity.readthedocs.io/en/latest/common-patterns.html#withdrawal-from-contracts[recommendation]
is to adopt a _withdrawal pattern_. In this solution, each user is
burdened with calling an isolated function (i.e. a _withdraw_ function)
which handles the sending of ether out of the contract and therefore
independently deals with the consequences of failed send transactions.
The idea is to logically isolate the external send functionality from
the rest of the code base and place the burden of potentially failed
transaction to the end-user who is calling the _withdraw_ function.

===== Real-World Example: Etherpot and King of the Ether

https://github.com/etherpot[Etherpot] was a smart contract lottery, not
too dissimilar to the example contract mentioned above. The solidity
code for etherpot, can be found here:
https://github.com/etherpot/contract/blob/master/app/contracts/lotto.sol[lotto.sol].
The primary downfall of this contract was due to an incorrect use of
block hashes (only the last 256 block hashes are useable, see Aakil
Fernandes’s
http://aakilfernandes.github.io/blockhashes-are-only-good-for-256-blocks[post]
about how Etherpot failed to implement this correctly). However this
contract also suffered from an unchecked call value. Notice the
function, `cash()` on line [80] of lotto.sol:

.lotto.sol: Code snippet 
[source,solidity,linenums]
----
...
  function cash(uint roundIndex, uint subpotIndex){

        var subpotsCount = getSubpotsCount(roundIndex);

        if(subpotIndex>=subpotsCount)
            return;

        var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);

        if(decisionBlockNumber>block.number)
            return;

        if(rounds[roundIndex].isCashed[subpotIndex])
            return;
        //Subpots can only be cashed once. This is to prevent double payouts

        var winner = calculateWinner(roundIndex,subpotIndex);    
        var subpot = getSubpot(roundIndex);

        winner.send(subpot);

        rounds[roundIndex].isCashed[subpotIndex] = true;
        //Mark the round as cashed
}
...
----

Notice that on line [21] the send function’s return value is not
checked, and the following line then sets a boolean indicating the
winner has been sent their funds. This bug can allow a state where the
winner does not receive their ether, but the state of the contract can
indicate that the winner has already been paid.

A more serious version of this bug occurred in the
https://www.kingoftheether.com/thrones/kingoftheether/index.html[King of
the Ether]. An excellent
https://www.kingoftheether.com/postmortem.html[post-mortem] of this
contract has been written which details how an unchecked failed `send()`
could be used to attack the contract.

==== Race Conditions / Front Running

The combination of external calls to other contracts and the multi-user
nature of the underlying blockchain gives rise to a variety of potential
Solidity pitfalls whereby users _race_ code execution to obtain
unexpected states. Re-Entrancy is one example of such
a race condition. In this section we will talk more generally about
different kinds of race conditions that can occur on the Ethereum
blockchain. There is a variety of good posts on this subject, a few are:
https://github.com/ethereum/wiki/wiki/Safety#race-conditions[Ethereum
Wiki - Safety], http://www.dasp.co/#item-7[DASP - Front-Running] and the
https://consensys.github.io/smart-contract-best-practices/known_attacks/#race-conditions[Consensus
- Smart Contract Best Practices].

===== The Vulnerability

As with most blockchains, Ethereum nodes pool transactions and form them
into blocks. The transactions are only considered valid once a miner has
solved a consensus mechanism (currently
https://github.com/ethereum/wiki/wiki/Ethash[ETHASH] PoW for Ethereum).
The miner who solves the block also chooses which transactions from the
pool will be included in the block, this is typically ordered by the
`gasPrice` of a transaction. In here lies a potential attack vector. An
attacker can watch the transaction pool for transactions which may
contain solutions to problems, modify or revoke the attacker’s
permissions or change a state in a contract which is undesirable for the
attacker. The attacker can then get the data from this transaction and
create a transaction of their own with a higher `gasPrice` and get their
transaction included in a block before the original.

Let’s see how this could work with a simple example. Consider the following
contract,

.FindThisHash.sol:
[source,solidity,linenums]
----
contract FindThisHash {
    bytes32 constant public hash = 0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a;
    
    constructor() public payable {} // load with ether
    
    function solve(string solution) public {
        // If you can find the pre image of the hash, receive 1000 ether
        require(hash == sha3(solution)); 
        msg.sender.transfer(1000 ether);
    }
}
----

Imagine this contract contains 1000 ether. The user who can find the
pre-image of the sha3 hash
`0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a` can
submit the solution and retrieve the 1000 ether. Lets say one user
figures out the solution is `Ethereum!`. They call `solve()` with
`Ethereum!` as the parameter. Unfortunately an attacker has been clever
enough to watch the transaction pool for anyone submitting a solution.
They see this solution, check it’s validity, and then submit an
equivalent transaction with a much higher `gasPrice` than the original
transaction. The miner who solves the block will likely give the
attacker preference due to the higher `gasPrice` and accept their
transaction before the original solver. The attacker will take the 1000
ether and the user who solved the problem will get nothing (there is no
ether left in the contract).

A more realistic problem comes in the design of the future Casper
implementation. The Casper proof of stake contracts invoke slashing
conditions where users who notice validators double-voting or
misbehaving are incentivised to submit proof that they have done so. The
validator will be punished and the user rewarded. In such a scenario, it
is expected that miners and users will front-run all such submissions of
proof, and this issue must be addressed before the final release.

===== Preventative Techniques

There are two classes of users who can perform these kinds of
front-running attacks. Users (who modify the `gasPrice` of their
transactions) and miners themselves (who can re-order the transactions
in a block how they see fit). A contract that is vulnerable to the first
class (users), is significantly worse-off than one vulnerable to the
second (miners) as miner’s can only perform the attack when they solve a
block, which is unlikely for any individual miner targeting a specific
block. Here we’ll list a few mitigation measures with relation to which
class of attackers they may prevent.

One method that can be employed is to create logic in the contract that
places an upper bound on the `gasPrice`. This prevents users from
increasing the `gasPrice` and getting preferential transaction ordering
beyond the upper-bound. This preventative measure only mitigates the
first class of attackers (arbitrary users). Miners in this scenario can
still attack the contract as they can order the transactions in their
block however they like, regardless of gas price.

A more robust method is to use a
https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract[commit-reveal]
scheme, whenever possible. Such a scheme dictates users send
transactions with hidden information (typically a hash). After the
transaction has been included in a block, the user sends a transaction
revealing the data that was sent (the reveal phase). This method
prevents both miners and users from frontrunning transactions as they
cannot determine the contents of the transaction. This method however,
cannot conceal the transaction value (which in some cases is the
valuable information that needs to be hidden). The
https://ens.domains/[ENS] smart contract allowed users to send
transactions, whose committed data included the amount of ether they
were willing to spend. Users could then send transactions of arbitrary
value. During the reveal phase, users were refunded the difference
between the amount sent in the transaction and the amount they were
willing to spend.

A further suggestion by Lorenz, Phil, Ari and Florian is to use
http://hackingdistributed.com/2017/08/28/submarine-sends/[Submarine
Sends]. An efficient implementation of this idea requires the `CREATE2`
opcode, which currently hasn’t been adopted, but seems likely in
upcoming hard forks.

===== Real-World Examples: ERC20 and Bancor

The https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md[ERC20]
standard is quite well-known for building tokens on Ethereum. This
standard has a potential frontrunning vulnerability which comes about
due to the `approve()` function. A good explanation of this
vulnerability can be found
https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit[here].

The standard specifies the `approve()` function as:

[source,solidity]
----
function approve(address _spender, uint256 _value) returns (bool success)
----

This function allows a user to permit other users to transfer tokens on
their behalf. The frontrunning vulnerability comes in the scenario when
a user, Alice, _approves_ her friend, `Bob` to spend `100 tokens`. Alice
later decides that she wants to revoke `Bob`’s approval to spend
`100 tokens`, so she creates a transaction that sets `Bob`’s allocation
to `50 tokens`. `Bob`, who has been carefully watching the chain, sees
this transaction and builds a transaction of his own spending the
`100 tokens`. He puts a higher `gasPrice` on his transaction than
`Alice`’s and gets his transaction prioritised over hers. Some
implementations of `approve()` would allow `Bob` to transfer his
`100 tokens`, then when `Alice`’s transaction gets committed, resets
`Bob`’s approval to `50 tokens`, in effect giving `Bob` access to
`150 tokens`. The mitigation strategies of this attack are given
https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit[here]
in the document linked above.

Another prominent, real-world example is
https://www.bancor.network/[Bancor]. Ivan Bogatty and his team
documented a profitable attack on the initial Bancor implementation. His
https://hackernoon.com/front-running-bancor-in-150-lines-of-python-with-ethereum-api-d5e2bfd0d798[blog
post] and https://www.youtube.com/watch?v=RL2nE3huNiI[Devon 3 talk]
discuss in detail how this was done. Essentially, prices of tokens are
determined based on transaction value, users can watch the transaction
pool for Bancor transactions and front run them to profit from the price
differences. This attack has been addressed by the Bancor team.

==== Denial Of Service (DOS)

This category is very broad, but fundamentally consists of attacks where
users can leave the contract inoperable for a small period of time, or
in some cases, permanently. This can trap ether in these contracts
forever, as was the case with the *Second Parity
MultiSig hack*.

===== The Vulnerability

There are various ways a contract can become inoperable. Here we
only highlight some potentially less-obvious Blockchain nuanced Solidity
coding patterns that can lead to attackers performing DOS attacks.

Looping through externally manipulated mappings or arrays::
This kind of pattern typically appears in scenarios where an `owner` wishes to distribute tokens
amongst their investors, and do so with a `distribute()`-like function
as can be seen in the example contract:

[source,solidity,linenums]
----
contract DistributeTokens {
    address public owner; // gets set somewhere
    address[] investors; // array of investors
    uint[] investorTokens; // the amount of tokens each investor gets
    
    // ... extra functionality, including transfertoken()
    
    function invest() public payable {
        investors.push(msg.sender);
        investorTokens.push(msg.value * 5); // 5 times the wei sent
        }
    
    function distribute() public {
        require(msg.sender == owner); // only owner
        for(uint i = 0; i < investors.length; i++) { 
            // here transferToken(to,amount) transfers "amount" of tokens to the address "to"
            transferToken(investors[i],investorTokens[i]); 
        }
    }
}
----

Notice that the loop in this contract runs over an array which can be
artificially inflated. An attacker can create many user accounts making
the `investor` array large. In principle this can be done such that the
gas required to execute the for loop exceeds the block gas limit,
essentially making the `distribute()` function inoperable.

Owner operations::
Another common pattern is where owners have
specific privileges in contracts and must perform some task in order for
the contract to proceed to the next state. One example would be an ICO
contract that requires the owner to `finalize()` the contract which then
allows tokens to be transferable, i.e.

[source,solidity,linenums]
----
bool public isFinalized = false;
address public owner; // gets set somewhere

function finalize() public {
    require(msg.sender == owner);
    isFinalized == true;
}

// ... extra ICO functionality

// overloaded transfer function
function transfer(address _to, uint _value) returns (bool) {
    require(isFinalized);
    super.transfer(_to,_value)
}

...
----

In such cases, if a privileged user loses their private keys, or becomes
inactive, the entire token contract becomes inoperable. In this case, if
the `owner` cannot call `finalize()` no tokens can be transferred;
i.e. the entire operation of the token ecosystem hinges on a single
address.

Progressing state based on external calls:: Contracts are sometimes written
such that in order to progress to a new state requires sending ether to an
address, or waiting for some input from an external source.  These patterns can
lead to DOS attacks when the external call fails or is prevented for external
reasons. In the example of sending ether, a user can create a contract which
does not accept ether. If a contract requires ether to be withdrawn (consider a
time-locking contract that requires all ether to be withdrawn before being
useable again) in order to progress to a new state, the contract will never
achieve the new state as ether can never be sent to the user's contract which
does not accept ether. 

===== Preventative Techniques

In the first example, contracts should not loop through data structures
that can be artificially manipulated by external users. A withdrawal
pattern is recommended, whereby each of the investors call a withdraw
function to claim tokens independently.

In the second example a privileged user was required to change the state
of the contract. In such examples (wherever possible) a fail-safe can be
used in the event that the `owner` becomes incapacitated. One solution
could be setting up the `owner` as a multisig contract. Another solution
is to use a timelock, where the require on line [13] could include a
time-based mechanism, such as
`require(msg.sender == owner || now > unlockTime)` which allows any user
to finalise after a period of time, specified by `unlockTime`. This kind
of mitigation technique can be used in the third example also. If
external calls are required to progress to a new state, account for
their possible failure and potentially add a time-based state
progression in the event that the desired call never comes.

_Note: Of course there are centralised alternatives to these suggestions
where one can add a `maintenanceUser` who can come along and fix
problems with DOS-based attack vectors if need be. Typically these kinds
of contracts contain trust issues over the power of such an entity._

===== Real-World Examples: GovernMental

http://governmental.github.io/GovernMental/[GovernMental] was an old
Ponzi scheme that accumulated quite a large amount of ether. In fact, at
one point it had accumulated 1100 ether. Unfortunately, it was
susceptible to the DOS vulnerabilities mentioned in this section.
https://www.reddit.com/r/ethereum/comments/4ghzhv/governmentals_1100_eth_jackpot_payout_is_stuck/[This
Reddit Post] describes how the contract required the deletion of a large
mapping in order to withdraw the ether. The deletion of this mapping had
a gas cost that exceeded the block gas limit at the time, and thus was
not possible to withdraw the 1100 ether. The contract address is
https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3[0xF45717552f12Ef7cb65e95476F217Ea008167Ae3]
and you can see from transaction
https://etherscan.io/tx/0x0d80d67202bd9cb6773df8dd2020e7190a1b0793e8ec4fc105257e8128f0506b[0x0d80d67202bd9cb6773df8dd2020e7190a1b0793e8ec4fc105257e8128f0506b]
that the 1100 ether was finally obtained with a transaction that used
2.5M gas (after the block gas limit allowed such a transaction).

==== Block Timestamp Manipulation

Block timestamps have historically been used for a variety of
applications, such as entropy for random numbers (see the
*Entropy Illusion* section for further details), locking
funds for periods of time and various state-changing conditional
statements that are time-dependent. Miner’s have the ability to adjust
timestamps slightly which can prove to be quite dangerous if block
timestamps are used incorrectly in smart contracts.

Some useful references for this are:
http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#block-and-transaction-properties[The
Solidity Docs], this
https://ethereum.stackexchange.com/questions/413/can-a-contract-safely-rely-on-block-timestamp?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa[Stack
Exchange Question].

===== The Vulnerability

`block.timestamp` or its alias `now` can be manipulated by miners if
they have some incentive to do so. Lets construct a simple game, which
would be vulnerable to miner exploitation,

.roulette.sol:
[source,solidity]
----
contract Roulette {
    uint public pastBlockTime; // Forces one bet per block
    
    constructor() public payable {} // initially fund contract
    
    // fallback function used to make a bet
    function () public payable {
        require(msg.value == 10 ether); // must send 10 ether to play
        require(now != pastBlockTime); // only 1 transaction per block
        pastBlockTime = now;
        if(now % 15 == 0) { // winner
            msg.sender.transfer(this.balance);
        }
    }
}
----

This contract behaves like a simple lottery. One transaction per block
can bet `10 ether` for a chance to win the balance of the contract. The
assumption here is that, `block.timestamp` is uniformly distributed
about the last two digits. If that were the case, there would be a 1/15
chance of winning this lottery.

However, as we know, miners can adjust the timestamp, should they need
to. In this particular case, if enough ether pooled in the contract, a
miner who solves a block is incentivised to choose a timestamp such that
`block.timestamp` or `now` modulo 15 is `0`. In doing so they may win
the ether locked in this contract along with the block reward. As there
is only one person allowed to bet per block, this is also vulnerable to
front-running attacks (see the *Front-Running* section for further details).

In practice, block timestamps are monotonically increasing and so miners
cannot choose arbitrary block timestamps (they must be larger than their
predecessors). They are also limited to setting blocktimes not too far
in the future as these blocks will likely be rejected by the network
(nodes will not validate blocks whose timestamps are in the future).

===== Preventative Techniques

Block timestamps should not be used for entropy or generating random
numbers - i.e. they should not be the deciding factor (either directly
or through some derivation) for winning a game or changing an important
state (if assumed to be random).

Time-sensitive logic is sometimes required; i.e. unlocking contracts
(timelocking), completing an ICO after a few weeks or enforcing expiry
dates. It is sometimes recommend to use `block.number` (see the
http://solidity.readthedocs.io/en/latest/units-and-global-variables.html#block-and-transaction-properties[Solidity
docs]) and an average block time to estimate times; .i.e. `1 week` with
a `10 second` block time, equates to approximately, `60480 blocks`.
Thus, specifying a block number at which to change a contract state can
be more secure as miners are unable to manipulate the block number as
easily. The
https://etherscan.io/address/0x0d8775f648430679a709e98d2b0cb6250d2887ef#code[BAT
ICO] contract employed this strategy.

This can be unnecessary if contracts aren’t particularly concerned with
miner manipulations of the block timestamp, but it is something to be
aware of when developing contracts.

===== Real-World Example: GovernMental

http://governmental.github.io/GovernMental/[GovernMental] was an old
Ponzi scheme that accumulated quite a large amount of ether. It was also
vulnerable to a timestamp-based attack. The contract payed out to the
player who was the last player to join (for at least one minute) in a
round. Thus, a miner who was a player, could adjust the timestamp (to a
future time, to make it look like a minute had elapsed) to make it
appear that the player was the last to join for over a minute (even
though this is not true in reality). More detail on this can be found in
the
https://applicature.com/blog/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes[History
of Ethereum Security Vulnerabilities Post] by Tanya Bahrynovska.

==== Constructors with Care

Constructors are special functions which often perform critical,
privileged tasks when initialising contracts. Before solidity `v0.4.22`
constructors were defined as functions that had the same name as the
contract that contained them. Thus, when a contract name gets changed in
development, if the constructor name isn’t changed, it becomes a normal,
callable function. As you can imagine, this can (and has) lead to some
interesting contract hacks.

For further insight, the reader may be interested attempting the
https://github.com/OpenZeppelin/ethernaut[Ethernaught Challenges] (in
particular the Fallout level).

===== The Vulnerability

If the contract name gets modified, or there is a typo in the
constructor's name such that it no longer matches the name of the
contract, the constructor will behave like a normal function. This can
lead to dire consequences, especially if the constructor is performing
privileged operations. Consider the following contract

[source,solidity,linenums]
----
contract OwnerWallet {
    address public owner;

    //constructor
    function ownerWallet(address _owner) public {
        owner = _owner;
    }
    
    // fallback. Collect ether.
    function () payable {} 
    
    function withdraw() public {
        require(msg.sender == owner); 
        msg.sender.transfer(this.balance);
    }
}
----

This contract collects ether and only allows the owner to withdraw all
the ether by calling the `withdraw()` function. The issue arises due to
the fact that the constructor is not exactly named after the contract.
Specifically, `ownerWallet` is not the same as `OwnerWallet`. Thus, any
user can call the `ownerWallet()` function, set themselves as the owner
and then take all the ether in the contract by calling `withdraw()`.

===== Preventative Techniques

This issue has been primarily addressed in the Solidity compiler in
version `0.4.22`. This version introduced a `constructor` keyword which
specifies the constructor, rather than requiring the name of the
function to match the contract name. Using this keyword to specify
constructors is recommended to prevent naming issues as highlighted
above.

===== Real-World Example: Rubixi

Rubixi
(https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code[contract
code]) was another pyramid scheme that exhibited this kind of
vulnerability. It was originally called `DynamicPyramid` but the
contract name was changed before deployment to `Rubixi`. The
constructor’s name wasn’t changed, allowing any user to become the
`creator`. Some interesting discussion related to this bug can be found
on this https://bitcointalk.org/index.php?topic=1400536.60[Bitcoin
Thread]. Ultimately, it allowed users to fight for `creator` status to
claim the fees from the pyramid scheme. More detail on this particular
bug can be found
https://applicature.com/blog/history-of-ethereum-security-vulnerabilities-hacks-and-their-fixes[here].

==== Unintialised Storage Pointers

The EVM stores data either as `storage` or as `memory`. Understanding
exactly how this is done and the default types for local variables of
functions is highly recommended when developing contracts. This is
because it is possible to produce vulnerable contracts by
inappropriately intialising variables.

To read more about `storage` and `memory` in the EVM, see the
http://solidity.readthedocs.io/en/latest/types.html#data-location[Solidity
Docs: Data Location],
http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage[Solidity
Docs: Layout of State Variables in Storage],
http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-in-memory[Solidity
Docs: Layout in Memory].

_This section is based off the excellent
https://medium.com/cryptronics/storage-allocation-exploits-in-ethereum-smart-contracts-16c2aa312743[post
by Stefan Beyer]. Further reading on this topic can be found from
Sefan’s inspiration, which is this
https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/[reddit
thread]._

===== The Vulnerability

Local variables within functions default to `storage` or `memory`
depending on their type. Uninitialised local `storage` variables can
point to other unexpected storage variables in the contract, leading to
intentional (i.e. the developer intentionally puts them there to attack
later) or unintentional vulnerabilities.

Let’s consider the following, relatively simple name registrar contract:

.NameRegistrar.sol
[source,solidity,linenums]
----
// A Locked Name Registrar
contract NameRegistrar {

    bool public unlocked = false;  // registrar locked, no name updates
    
    struct NameRecord { // map hashes to addresses
        bytes32 name;  
        address mappedAddress;
    }

    mapping(address => NameRecord) public registeredNameRecord; // records who registered names 
    mapping(bytes32 => address) public resolve; // resolves hashes to addresses
    
    function register(bytes32 _name, address _mappedAddress) public {
        // set up the new NameRecord
        NameRecord newRecord;
        newRecord.name = _name;
        newRecord.mappedAddress = _mappedAddress; 

        resolve[_name] = _mappedAddress;
        registeredNameRecord[msg.sender] = newRecord; 

        require(unlocked); // only allow registrations if contract is unlocked
    }
}
----

This simple name registrar has only one function. When the contract is
`unlocked`, it allows anyone to register a name (as a `bytes32` hash)
and map that name to an address. Unfortunately, this registrar is
initially locked and the `require` on line [23] prevents `register()`
from adding name records. There is however a vulnerability in this
contract, that allows name registration regardless of the `unlocked`
variable.

// TODO: Andreas to check if this introduction is required as another section
// of the book may be able to be referenced. The language may also need to be 
// adjusted.

To discuss this vulnerability, first we need to understand how storage
works in Solidity. As a high level overview (without any proper
technical detail - we suggest reading the Solidity docs for a proper
review), state variables are stored sequentially in _slots_ as they
appear in the contract (they can be grouped together, but not in this
example, so we wont worry about that). Thus, `unlocked` exists in
`slot 0`, `registeredNameRecord` exists in `slot 1` and `resolve` in
`slot 2` etc. Each of these slots are of byte size 32 (there are added
complexities with mappings which we ignore for now). The boolean
`unlocked` will look like `0x000...0` (64 `0`’s, excluding the `0x`) for
`false` or `0x000...1`(63 `0`’s) for `true`. As you can see, there is a
significant waste of storage in this particular example.

The next piece of the puzzle, is that Solidity defaults
complex data types, such as `structs`, to `storage` when initialising
them as local variables. Therefore, `newRecord` on line [16] defaults to
`storage`. The vulnerability is caused by the fact that `newRecord` is
not initialised. Because it defaults to storage, it becomes a pointer to
storage and because it is uninitialised, it points to slot `0`
(i.e. where `unlocked` is stored). Notice that on lines [17] and [18] we
then set `nameRecord.name` to `_name` and `nameRecord.mappedAddress` to
`_mappedAddress`, this in effect changes the storage location of slot 0
and slot 1 which modifies both `unlocked` and the storage slot
associated with `registeredNameRecord`.

This means that `unlocked` can be directly modified, simply by the
`bytes32 _name` parameter of the `register()` function. Therefore, if
the last byte of `_name` is non-zero, it will modify the last byte of
storage `slot 0` and directly change `unlocked` to `true`. Such `_name`
values will pass the `require()` on line [23] as we are setting
`unlocked` to `true`. Try this in Remix. Notice the function will pass
if you use a `_name` of the form:
`0x0000000000000000000000000000000000000000000000000000000000000001`

===== Preventative Techniques

The Solidity compiler raises unintialised storage variables as warnings,
thus developers should pay careful attention to these warnings when
building smart contracts. The current version of mist (0.10), doesn’t
allow these contracts to be compiled. It is often good practice to
explicitly use the `memory` or `storage` when dealing with complex types
to ensure they behave as expected.

===== Real-World Examples: Honey Pots: OpenAddressLottery and CryptoRoulette

A honey pot named OpenAddressLottery
(https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code[contract
code]) was deployed that used this uninitialised storage variable querk
to collect ether from some would-be hackers. The contract is rather
in-depth, so we will leave the analysis to this
https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/[reddit
thread] where the attack is quite clearly explained.

Another honey pot, CryptoRoulette
(https://etherscan.io/address/0x8685631276cfcf17a973d92f6dc11645e5158c0c#code[contract
code]) also utilises this trick to try and collect some ether. If you
can’t figure out how the attack works, see
https://medium.com/@jsanjuas/an-analysis-of-a-couple-ethereum-honeypot-contracts-5c07c95b0a8d[An
analysis of a couple Ethereum honeypot contracts] for an overview of
this contract and others.

==== Floating Points and Precision

As of this writing (Solidity v0.4.24), fixed point or floating point
numbers are not supported. This means that floating point
representations must be made with the integer types in Solidity. This
can lead to errors/vulnerabilities if not implemented correctly.

For further reading, see
https://github.com/ethereum/wiki/wiki/Safety#beware-rounding-with-integer-division[Ethereum
Contract Security Techniques and Tips - Rounding with Integer Division],

===== The Vulnerability

As there is no fixed point type in Solidity, developers are required to
implement their own using the standard integer data types. There are a
number of pitfalls developers can run into during this process. I will
try to highlight some of these in this section.

Lets begin with a code example (lets ignore any over/under flow issues
for simplicity).

[source,solidity,linenums]
----
contract FunWithNumbers {
    uint constant public tokensPerEth = 10; 
    uint constant public weiPerEth = 1e18;
    mapping(address => uint) public balances;

    function buyTokens() public payable {
        uint tokens = msg.value/weiPerEth*tokensPerEth; // convert wei to eth, then multiply by token rate
        balances[msg.sender] += tokens; 
    }
    
    function sellTokens(uint tokens) public {
        require(balances[msg.sender] >= tokens);
        uint eth = tokens/tokensPerEth; 
        balances[msg.sender] -= tokens;
        msg.sender.transfer(eth*weiPerEth); //
    }
}
----

This simple token buying/selling contract has some obvious problems in
the buying and selling of tokens. Although the mathematical calculations
for buying and selling tokens are correct, the lack of floating point
numbers will give erroneous results. For example, when buying tokens on
line [7], if the value is less than `1 ether` the initial division will
result in `0`, leaving the final multiplication `0` (i.e. `200 wei`
divided by `1e18` `weiPerEth` equals `0`). Similarly, when selling
tokens, any tokens less than `10` will also result in `0 ether`. In
fact, rounding here is always down, so selling `29 tokens`, will result
in `2 ether`.

The issue with this contract is that the precision is only to the
nearest `ether` (i.e. `1e18 wei`). This can sometimes get tricky when
dealing with `decimals` in
https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md[ERC20]
tokens when you need higher precisions.

===== Preventative Techniques

Keeping the right precision in your smart contracts is very important,
especially when dealing ratios and rates which reflect economic
decisions.

You should ensure that any ratios or rates you are using allow for large
numerators in fractions. For example, we used the rate `tokensPerEth` in
our example. It would have been better to use `weiPerTokens` which would
be a large number. To solve for the amount of tokens we could do
`msg.sender/weiPerTokens`. This would give a more precise result.

Another tactic to keep in mind, is to be mindful of order of operations.
In the above example, the calculation to purchase tokens was
`msg.value/weiPerEth*tokenPerEth`. Notice that the division occurs
before the multiplication. This example would have achieved a greater
precision if the calculation performed the multiplication first and then
the division, i.e. `msg.value*tokenPerEth/weiPerEth`.

Finally, when defining arbitrary precision for numbers it can be a good
idea to convert variables into higher precision, perform all
mathematical operations, then finally when needed, convert back down to
the precision for output. Typically `uint256`’s are used (as they are
optimal for gas usage) which give approximately 60 orders of magnitude
in their range, some which can be dedicated to the precision of
mathematical operations. It may be the case that it is better to keep
all variables in high precision in solidity and convert back to lower
precisions in external apps (this is essentially how the `decimals`
variable works in
https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md[ERC20 Token]
contracts). To see examples of how this can be done and the libraries to
do this, we recommend looking at the
https://github.com/dapphub/ds-math[Maker DAO DSMath]. They use some
funky naming, `WAD`’s and `RAY`’s but the concept is useful.

===== Real-World Example: Ethstick

The contract https://etherscan.io/address/0xbA6284cA128d72B25f1353FadD06Aa145D9095Af#code[Ethstick]
 does not use any extended precision, however, it deals with `wei`. So
this contract will have issues of rounding, but only at the `wei` level
of precision. It has some more serious flaws, but these are relating
back to the difficulty in getting entropy on the blockchain (see
*Entropty Illusion*). For a further discussion on
the Ethstick contract, I’ll refer you to another post of Peter Venesses,
https://vessenes.com/ethereum-contracts-are-going-to-be-candy-for-hackers/[Ethereum
Contracts Are Going to be Candy For Hackers].

==== Tx.Origin Authentication

Solidity has a global variable, `tx.origin` which traverses the entire
call stack and returns the address of the account that originally sent
the call (or transaction). Using this variable for authentication in
smart contracts leaves the contract vulnerable to a phishing-like
attack.

For further reading, see
https://ethereum.stackexchange.com/questions/1891/whats-the-difference-between-msg-sender-and-tx-origin[Stack
Exchange Question],
https://vessenes.com/tx-origin-and-ethereum-oh-my/[Peter Venesses’s
Blog] and
https://medium.com/coinmonks/solidity-tx-origin-attacks-58211ad95514[Solidity
- Tx.Origin attacks].

===== The Vulnerability

Contracts that authorise users using the `tx.origin` variable are
typically vulnerable to phishing attacks which can trick users into
performing authenticated actions on the vulnerable contract.

Consider the simple contract,

.Phishable.sol
[source,solidity,linenums]
----
contract Phishable {
    address public owner;
    
    constructor (address _owner) {
        owner = _owner; 
    }
    
    function () public payable {} // collect ether

    function withdrawAll(address _recipient) public {
        require(tx.origin == owner);
        _recipient.transfer(this.balance); 
    }
}
----

Notice that on line [11] this contract authorises the `withdrawAll()`
function using `tx.origin`. This contract allows for an attacker to
create an attacking contract of the form,

[source,solidity,linenums]
----
import "Phishable.sol";

contract AttackContract { 
    
    Phishable phishableContract; 
    address attacker; // The attackers address to receive funds.

    constructor (Phishable _phishableContract, address _attackerAddress) { 
        phishableContract = _phishableContract; 
        attacker = _attackerAddress;
    }
    
    function () payable { 
        phishableContract.withdrawAll(attacker); 
    }
}
----

To utilise this contract, an attacker would deploy it, and then convince
the owner of the `Phishable` contract to send this contract some amount
of ether. The attacker may disguise this contract as their own private
address and social engineer the victim to send some form of transaction
to the address. The victim, unless being careful, may not notice that
there is code at the attacker’s address, or the attacker may pass it off
as being a multisignature wallet or some advanced storage wallet (remember
source code of public contracts is not available by default).

In any case, if the victim sends a transaction (with enough gas) to the
`AttackContract` address, it will invoke the fallback function, which in
turn calls the `withdrawAll()` function of the `Phishable` contract,
with the parameter `attacker`. This will result in the withdrawal of all
funds from the `Phishable` contract to the `attacker` address. This is
because the address that first initialised the call was the victim
(i.e. the `owner` of the `Phishable` contract). Therefore, `tx.origin`
will be equal to `owner` and the `require` on line [11] of the
`Phishable` contract will pass.

===== Preventative Techniques

`tx.origin` should not be used for authorisation in smart contracts.
This isn’t to say that the `tx.origin` variable should never be used. It
does have some legitimate use cases in smart contracts. For example, if
one wanted to deny external contracts from calling the current contract,
they could implement a `require` of the from
`require(tx.origin == msg.sender)`. This prevents intermediate contracts
being used to call the current contract, limiting the contract to
regular code-less addresses.

[[security_best_practices_sec]]
==== Security best practices

There is a lot for any developer working in the smart contract domain to know and understand. By following best practices in your smart contract design and code writing, you will avoid many severe pitfalls and traps. Here are some links for you to explore on the topic:

https://consensys.github.io/smart-contract-best-practices/

https://blog.zeppelin.solutions/onward-with-ethereum-smart-contract-security-97a827e47702

https://medium.com/zeppelin-blog/the-hitchhikers-guide-to-smart-contracts-in-ethereum-848f08001f05#.cox40d2ut

https://blog.sigmaprime.io/solidity-security.html

Perhaps the most fundamental software security principle is to maximize reuse of trusted code. In cryptography, this is so important, it has been condensed in an adage: "Don't roll your own crypto". In the case of smart contracts, this amounts to gaining as much as possible from freely available libraries that have been thoroughly vetted by the community.

[[contract_libraries_sec]]
==== Contract libraries

There is a lot of existing code available both deployed on-chain as callable libraries and off-chain as code template libraries. On-platform libraries, having been deployed, exist as bytecode smart contracts and so great care should be taken before using them in production. However, using well established existing on-platform libraries comes with many advantages, such as being able to benefit from the latest upgrades, but it also simply saves you money and benefits the Ethereum ecosystem by keeping the number of contracts in the Ethereum state down.

In Ethereum, the most widely used resource is the https://openzeppelin.org/[OpenZeppelin] suite; an ample library of contracts ranging from implementations of `ERC20` and `ERC721` tokens, to many flavors of crowdsale models, to simple behaviors commonly found in contracts, such as `Ownable`, `Pausable` or `LimitBalance`. The contracts in this repository have been extensively tested and in some cases even function as _de facto_ standard implementations. They are free to use, and are built and maintained by https://zeppelin.solutions[Zeppelin] together with an ever growing list of external contributors.

Also from Zeppelin is https://zeppelinos.org/[zeppelin_os], an open source platform of services and tools to develop and manage smart contract applications securely. zeppelin_os provides a layer on top of the EVM that makes it easy for developers to launch upgradeable DApps linked to an on-chain library of well tested contracts that are themselves upgradeable. Different versions of these libraries can coexist on the Ethereum platform, and a vouching system allows users to propose or push improvements in different directions. A set of off-chain tools to debug, test, deploy, and monitor decentralized applications is also provided by the platform.

The project +ethpm+ aims to organize the various resources that are developing in the ecosystem by providing a package management system. As such, their registry provides more examples for you to browse:

* Website: https://www.ethpm.com/
* Repository link: https://www.ethpm.com/registry
* Github link: https://github.com/ethpm
* Documentation: https://www.ethpm.com/docs/integration-guide


[[testing_frameworks]]
=== Testing smart contracts

////
TODO: add paragraph
////


[[testing_frameworks_sec]]
==== Test Frameworks

There are several commonly-used test frameworks for smart contract development, summarized in <<testing_frameworks_table>>, below:

[[testing_frameworks_table]]
.Smart Contract Test Frameworks
|=======
|Framework | Test Language(s)    | Testing Framework | Chain Emulator       | Website
|Truffle   | Javascript/Solidity | Mocha             | TestRPC/Ganache      | truffleframework.com
|Embark    | Javascript          | Mocha             | TestRPC/Ganache      | embark.readthedocs.io
|DApp      | Solidity            | ds-test (custom)  | Ethrun (Parity)      | dapp.readthedocs.io
|Populus   | Python              | Pytes             | Python chain emulator| populus.readthedocs.io
|=======


Truffle Test:: Part of the Truffle framework, Truffle allows for unit tests to be written in JavaScript (Mocha based) or Solidity. These tests are run against Ganache.

Embark Framework Testing:: Embark integrates with Mocha to run unit tests written in JavaScript. The tests are in turn run against contracts deployed on TestRPC/Ganache. The Embark Framework automatically deploys smart contracts and will automatically redeploy the contracts when they are changed. It also keeps track of deployed contracts and deploys contracts when truly needed. Embark includes a testing library to rapidly run and test your contracts in an EVM, with functions like +assert.equal()+. The command +embark test+ will run any test files under directory test/.

DApp:: DApp uses native Solidity code (a library called ds-test) and a Parity built Rust library called Ethrun to execute Ethereum bytecode and then assert correctness. The ds-test library provides assertion functions for validating correctness and events for logging data in the console.

Assertions functions include:

----
assert(bool condition)
assertEq(address a, address b)
assertEq(bytes32 a, bytes32 b)
assertEq(int a, int b)
assertEq(uint a, uint b)
assertEq0(bytes a, bytes b)
expectEventsExact(address target)
----

Logging commands will log information to the console, making them useful for debugging:


----
logs(bytes)
log_bytes32(bytes32)
log_named_bytes32(bytes32 key, bytes32 val)
log_named_address(bytes32 key, address val)
log_named_int(bytes32 key, int val)
log_named_uint(bytes32 key, uint val)
log_named_decimal_int(bytes32 key, int val, uint decimals)
log_named_decimal_uint(bytes32 key, uint val, uint decimals)
----

Populus:: Populus uses python and its own chain emulator to run contracts written in Solidity. Unit tests are written in Python with the +pytest+ library. Populus supports writing contracts that are specifically for testing. These contract filenames should match the glob pattern +Test*.sol+ and be located anywhere under the project tests directory +tests+.


[[on_blockchain_testing_sec]]
==== On-Blockchain Testing

Although most testing shouldn't occur on deployed contracts, a contract's behavior can be checked via Ethereum clients.  The following commands can be used to assess a smart contract's state. These commands should be typed at the '+geth+' terminal, although any web3 console will also support these commands.

....
eth.getTransactionReceipt(txhash);
....
Can be used to get the address of a contract at `+txhash+`.
....
eth.getCode(contractaddress)
....
Gets the code of a contract deployed at `+contractaddress+`. This can be used to verify proper deployment.
....
eth.getPastLogs(options)
....
Gets the full logs of the contract located at address, specified in options. This is helpful for viewing the history of a contract's calls.
....
eth.getStorageAt(address, position)
....
Gets the storage located at `+address+` with an offset of `+position+` shows the data stored in that contract.
